# 时间日期

## pandas 时间日期

本文开始将介绍 pandas 日期时间方面的功能。

主要内容有：

- 时间相关概念
- 时间序列创建
- 时间戳转换（指定格式，错误处理）
- 多列合成时间
- 新纪元时间
- 生成时间范围
- 自定义时间周期
- 最大最小时间
- 时间作为索引
- 按时间索引查询
- 时间日期的属性
- 日期偏移量（DateOffset）
- 日期偏移量计算
- DateOffset 属性
- 自定义工作时间
- Offset 别名
- 时间前后移动
- 时间周期转换
- 时间缺失值填充
- 与 python 时间类型转换
- 重采样
- 时间区间
- 周期转换
- 时区处理
- 时长定义与解析
- 时间长的操作
- 时长单位转换
- 时长的属性
- 时长作为索引
- 时长重采样

```python
# 前一年
df.assign(ago_1y=lambda m: m.day.apply(lambda x: x - pd.DateOffset(years=1)))
# 指定格式转为日期
df['p_day'] = pd.to_datetime(df.p_day, format='%Y%m%d', errors='ignore')
# 去年今日移动，实现同比
df['Previous'] = df.groupby([df['p_day'].dt.month,df['p_day'].dt.day])['qty'].shift()
```

## 时间基本概念

### 固定时间

这个非常简单，它是一个独立的时间，不在任何周期时，比如中午 13:30 睡觉，不代表你每半个小时就睡一次。其他的如，2020 年、农历四月十八、19世纪等等。

固定的时间有一定的属性，如所在年、月、日、毫秒等。

### 时间戳 timestamp



Unix时间戳(Unix timestamp)，时间戳是指格林威治时间1970年01月01日00时00分00秒起至当下的总秒数。它是一个非常大的数字，一直以一秒的步长在增加。如：1591684854 代表北京时间 2020/6/9 14:40:54。那么 1970年 年以前的时间怎么表示呢？用负数，如-1591684957 代表1919/7/26 2:17:23。



### 时间差 Time deltas



代表一个时间长度，但它没有指定的开始时间和结束时间，比如一首歌4分钟，你不管从什么时候开始，它都会占用4分钟。



### 格式化时间



由于原始时间数据可能是时间戳，也有可能是其他类型的数据，我们在使用时想按照一定的格式进行显示，就需要做格式化处理。如时间戳 1591684854 和 2020/6/9 14:40:54 转换为为 2020年06月09日 这样的中文格式。



### 周期时间



有开始、有结束，并且有时间单位周期的时间，比如从大学毕业后，我开始工作，每周一到周五去工作，持续到65岁退休，这个就是工作日周期。另如钟表，每半小时响一次，开始时间是我安装好它，结束时间是它坏掉的时候。



### 日期偏移 Date offsets



周期时间中有一个频率，一个频率是一个单位，日期偏移是基于这个频率，如一个周期的频率是小时，那偏移三个频率就是三小时。比如偏移一个工作周，这个工作周期是自己定义的。



### 时区



每个固定的时间都会有一个时区，一般为你电脑本地的时区，当然你根据需要可以进行调整。



### 工作日



在数据分析时，经常会与是否工作日相关，除了正常的周末，每个国家和地区节假日，甚至具体到一些公司都会有一些特定的作息，一般需要自己来指定这个工作日的周期。



### 时间转换



时间转换包括时间表达格式的转换，也会有一些时间计算，比如给一个时间，转为去年的当天、100天前的当天、转换为特定时区的时间等等。



## 时间序列的数据类型

### 数据类型

主要有：

| 概念                  | 标量       | Array 类       | pandas 类型                          | 创建方法                        |
| --------------------- | ---------- | -------------- | ------------------------------------ | ------------------------------- |
| 固定时间 Date times   | Timestamp  | DatetimeIndex  | datetime64[ns] or datetime64[ns, tz] | to_datetime or date_range       |
| 时长 Time deltas      | Timedelta  | TimedeltaIndex | timedelta64[ns]                      | to_timedelta or timedelta_range |
| 周期 Time spans       | Period     | PeriodIndex    | period[freq]                         | Period or period_range          |
| 日期偏移 Date offsets | DateOffset | None           | None                                 | DateOffset                      |

通常时间序列数据作为 Series 或 DataFrame 的索引，以方便对时间数据进行操作。

```python
# 指定开始时间和频率，周期数
pd.Series(range(3), index=pd.date_range('2000', freq='D', periods=3))
'''
2000-01-01    0
2000-01-02    1
2000-01-03    2
Freq: D, dtype: int64
'''
```

当传递给这些构造函数时，Series 和 DataFrame 具有扩展的数据类型，以支持时间类型 和 Period 周期数据类型功能，但是 DateOffset 数据将存储为 object 对象数据。

```python
pd.Series(pd.period_range('1/1/2011', freq='M', periods=3))
'''
0    2011-01
1    2011-02
2    2011-03
dtype: period[M]
'''

pd.Series([pd.DateOffset(1), pd.DateOffset(2)])
'''
0         <DateOffset>
1    <2 * DateOffsets>
dtype: object
'''

pd.Series(pd.date_range('1/1/2011', freq='M', periods=3))
'''
0   2011-01-31
1   2011-02-28
2   2011-03-31
dtype: datetime64[ns]
'''
```

也可以在 Series 和 DataFrame 中将时间序列作为具体的值：

```python
pd.Series(pd.date_range('2000', freq='D', periods=3))
'''
0   2000-01-01
1   2000-01-02
2   2000-01-03
dtype: datetime64[ns]
'''
```

对于时间的缺失值，有专门的 `NaT` 来表示：

```python
pd.Timestamp(pd.NaT)
# NaT

pd.Timedelta(pd.NaT)
# NaT

pd.Period(pd.NaT)
# NaT

# 类似 np.nan
pd.NaT == pd.NaT
# False
```

### 各类功能举例

可以使用以下几个方法将一个数据转化为时间类型：

```python
import datetime
dti = pd.to_datetime(['1/1/2018', # 类时间字符串
                      np.datetime64('2018-01-01'), # numpy 的时间类型
                      datetime.datetime(2018, 1, 1)]) # python 自带时间类型
dti
'''
DatetimeIndex(['2018-01-01', 
               '2018-01-01', 
               '2018-01-01'], 
              dtype='datetime64[ns]', freq=None)
'''
```

生成时间范围固定频率的序列，以下周期频率为小时：

```python
dti = pd.date_range('2018-01-01', periods=3, freq='H')
dti
'''
DatetimeIndex(['2018-01-01 00:00:00', '2018-01-01 01:00:00',
               '2018-01-01 02:00:00'],
              dtype='datetime64[ns]', freq='H')
'''
```

时区的转换：

```python
dti = dti.tz_localize('UTC')
dti
'''
DatetimeIndex(['2018-01-01 00:00:00+00:00', '2018-01-01 01:00:00+00:00',
               '2018-01-01 02:00:00+00:00'],
              dtype='datetime64[ns, UTC]', freq='H')
'''
dti.tz_convert('US/Pacific')
'''
DatetimeIndex(['2017-12-31 16:00:00-08:00', '2017-12-31 17:00:00-08:00',
               '2017-12-31 18:00:00-08:00'],
              dtype='datetime64[ns, US/Pacific]', freq='H')
'''
```

将时间序列重采样或转换为特定频率：

```python
idx = pd.date_range('2018-01-01', periods=5, freq='H')
ts = pd.Series(range(len(idx)), index=idx)
ts
'''
2018-01-01 00:00:00    0
2018-01-01 01:00:00    1
2018-01-01 02:00:00    2
2018-01-01 03:00:00    3
2018-01-01 04:00:00    4
Freq: H, dtype: int64'
'''
# 将一小时转换为两小时，聚合时取均值
ts.resample('2H').mean()
'''
2018-01-01 00:00:00    0.5
2018-01-01 02:00:00    2.5
2018-01-01 04:00:00    4.0
Freq: 2H, dtype: float64
'''
```

以绝对或相对时间增量执行日期和时间计算：

```python
friday = pd.Timestamp('2018-01-05')

friday.day_name()
# 'Friday'

# 增加一天
saturday = friday + pd.Timedelta('1 day')
saturday.day_name()
# 'Saturday'

# 增加一个工作日，从周五到周一
monday = friday + pd.offsets.BDay()
monday.day_name()
# 'Monday'
```

## pandas 定义固定时间

### 定义一个时间

`pd.Timestamp()` 是定义时间的主要函数，代替 python 中的 datetime.datetime 对象。

### 使用 python 的 datetime 库

```python
import datetime
# 至少需要年月日
pd.Timestamp(datetime.datetime(2020, 6, 8))
# Timestamp('2020-06-08 00:00:00')

# 指定是时分秒
pd.Timestamp(datetime.datetime(2020, 6, 8, 16, 17, 18))
# Timestamp('2020-06-08 16:17:18')
```

### 指定时间字符串

```python
pd.Timestamp('2012-05-01')
# Timestamp('2012-05-01 00:00:00')
pd.Timestamp('2017-01-01T12')
# Timestamp('2017-01-01 12:00:00')
```

### 指定时间位置数字

可以依次定义 year, month, day，hour, minute, second, microsecond：

```python
pd.Timestamp(2012, 5, 1)
# Timestamp('2012-05-01 00:00:00')
pd.Timestamp(2017, 1, 1, 12)
# Timestamp('2017-01-01 12:00:00')
pd.Timestamp(year=2017, month=1, day=1, hour=12)
# Timestamp('2017-01-01 12:00:00')
```

### 解析时间戳

```python
pd.Timestamp(1513393355.5, unit='s') # 单位为秒
# Timestamp('2017-12-16 03:02:35.500000')
```

### 指定时区

```python
pd.Timestamp(1513393355, unit='s', tz='US/Pacific')
# Timestamp('2017-12-15 19:02:35-0800', tz='US/Pacific')
# 指定为北京时间
pd.Timestamp(1513393355, unit='s', tz='Asia/Shanghai')
# Timestamp('2017-12-16 11:02:35+0800', tz='Asia/Shanghai')
```

### 特殊时间

以下可取得当前时间，从而可通过属性取到今天日期、年份等信息：

```python
pd.Timestamp('today')
pd.Timestamp('now')
# Timestamp('2020-06-09 16:11:56.532981')
pd.Timestamp('today').date() # 只取日期
```

也可以计算出昨天、明天等信息：

```python
# 昨天
pd.Timestamp('now')-pd.Timedelta(days=1)
# Timestamp('2020-06-08 16:14:39.254365')
# 明天
pd.Timestamp('now')+pd.Timedelta(days=1)
# Timestamp('2020-06-10 16:15:28.019039')
# 当月初，一日
pd.Timestamp('now').replace(day=1)
# Timestamp('2020-06-01 16:15:28.019039')
```

### 时间限制

由于 Pandas 以纳秒粒度表示时间戳，因此可以使用64位整数表示的时间跨度限制为大约584年：

```python
pd.Timestamp.min
# Timestamp('1677-09-21 00:12:43.145225')
pd.Timestamp.max
# Timestamp('2262-04-11 23:47:16.854775807')
```

以上为支持的最早最晚时间。

## 时间属性的操作

### 时间属性

我们先定义一个当前时间：

```
time = pd.Timestamp('now')
# Timestamp('2020-06-09 16:30:54.813664')
```

以下是丰富的时间属性：

```python
time.asm8 # 返回 numpy datetime64格式（以纳秒为单位）。
# numpy.datetime64('2020-06-09T16:30:54.813664000')
time.dayofweek # 1 周几，周一为0
time.day_of_week # 同上
time.dayofyear # 161, 一年的第几天
time.day_of_year # 同上
time.days_in_month # 30 当月有多少天
time.daysinmonth # 30 同上
time.freqstr # None, 周期字符
time.is_leap_year # True 是否闰年，公历的
time.is_month_end # False 是否当月最后一天
time.is_month_start # False 是否当月第一天
time.is_quarter_end # False 是否当季最后一天
time.is_quarter_start # False 是否当季第一天
time.is_year_end # 是否当年最后一天
time.is_year_start # 是否当年第一天
time.quarter # 2 当前季度数
# 如指定会返回类似 <DstTzInfo 'Asia/Shanghai' CST+8:00:00 STD>
time.tz # None 当前时区别名
time.week # 24 当年第几周
time.weekofyear # 24 同上
time.day # 9 日
time.fold # 0
time.freq # None 频度周期
time.hour # 16
time.microsecond # 890462
time.minute # 46
time.month # 6
time.nanosecond # 0
time.second # 59
time.tzinfo # None
time.value # 1591721219890462000
time.year # 2020
```

### 时间方法

取一个当前时间，并指定时区为北京时间：

```python
time = pd.Timestamp('now', tz='Asia/Shanghai')
# Timestamp('2020-06-09 16:55:58.027896+0800', tz='Asia/Shanghai')
```

方法如下：

```python
# 转换为指定时区
time.astimezone('UTC')
# Timestamp('2020-06-09 08:55:58.027896+0000', tz='UTC')

# 转换单位，向上舍入
time.ceil('s') # 转为以秒为单位
# Timestamp('2020-06-09 16:55:59+0800', tz='Asia/Shanghai')
time.ceil('ns') # 转为以纳秒为单位
time.ceil('d') # 保留日
time.ceil('h') # 保留时

# 转换单位, 为向下舍入
time.floor('h') # 保留时
# Timestamp('2020-06-09 17:00:00+0800', tz='Asia/Shanghai')

# 类似四舍五入
time.round('h') # 保留时

# 返回星期名
time.day_name() # 'Tuesday'
# 月份名称
time.month_name() # 'June'

# 将时间戳规范化为午夜，保留tz信息。
time.normalize()
# Timestamp('2020-06-09 00:00:00+0800', tz='Asia/Shanghai')

# 时间元素替换 datetime.replace，可处理纳秒。
time.replace(year=2019) # 年份换为2019年
# Timestamp('2019-06-09 17:14:44.126817+0800', tz='Asia/Shanghai')
time.replace(month=8) # 月份换为8月
# Timestamp('2020-08-09 17:14:44.126817+0800', tz='Asia/Shanghai')

# 转为周期类型，将丢失时区
time.to_period(freq='h') # 周期为小时
# Period('2020-06-09 17:00', 'H')

# 转为指定时区
time.tz_convert('UTC') # 转为 utc 时间
# Timestamp('2020-06-09 09:14:44.126817+0000', tz='UTC')

# 本地化时区转换
time = pd.Timestamp('now')
time.tz_localize('Asia/Shanghai')
# Timestamp('2020-06-09 17:32:47.388726+0800', tz='Asia/Shanghai')
time.tz_localize(None) # 删除时区
```

### .dt 时间访问器

对于时间序列数据，可以使用 `s.dt.xxx` 的形式来访问它们的属性和调用它们的方法：

```python
s = pd.Series(pd.date_range('2020-01-01', periods=3, freq='d'))
s.dt.date
s.dt.time
s.dt.timetz
s.dt.year
s.dt.month
s.dt.day
s.dt.hour
s.dt.minute
s.dt.second
s.dt.microsecond
s.dt.nanosecond
s.dt.week  # 2.0 已经弃用，新方法见下文
s.dt.weekofyear  # 2.0 已经弃用，新方法见下文
s.dt.dayofweek
s.dt.weekday
s.dt.dayofyear
s.dt.quarter
s.dt.is_month_start
s.dt.is_month_end
s.dt.is_quarter_start
s.dt.is_quarter_end
s.dt.is_year_start
s.dt.is_year_end
s.dt.is_leap_year
s.dt.daysinmonth
s.dt.days_in_month
s.dt.tz
s.dt.freq
s.dt.to_period
s.dt.to_pydatetime
s.dt.tz_localize
s.dt.tz_convert
s.dt.normalize
s.dt.strftime
s.dt.round
s.dt.floor
s.dt.ceil
s.dt.month_name
s.dt.day_name
s.dt.qyear
s.dt.start_time
s.dt.end_time
s.dt.days
s.dt.seconds
s.dt.microseconds
s.dt.nanoseconds
s.dt.components
s.dt.to_pytimedelta
s.dt.total_seconds

# 时间的年、周数、星期 DataFrame
s.dt.isocalendar()
s.dt.isocalendar().week # 获取周数

# 个别用法举例
s.dt.tz_localize('UTC').dt.tz_convert('US/Eastern')
s.dt.strftime('%Y/%m/%d')
```

对于固定时间会返回固定的结果，对于这序列会返回对应值的序列。

## 时间类型转换

### astype() 转换

`astype` 是最简单的时间转换方法，它只能针对相对标准的时间格式，如：

```python
s = pd.Series(['2016-01-31', '2016-02-29', '2016-03-31'])
s.astype('datetime64[ns]')
'''
0   2016-01-31
1   2016-02-29
2   2016-03-31
dtype: datetime64[ns]
'''
```

如果需要指定时区：

```python
s = pd.Series(['2016-01-31', '2016-02-29', '2016-03-31'])
s.astype('datetime64[ns, US/Eastern]')
'''
0   2016-01-31 00:00:00-05:00
1   2016-02-29 00:00:00-05:00
2   2016-03-31 00:00:00-04:00
dtype: datetime64[ns, US/Eastern]
'''
# 北京时间是 Asia/Shanghai
```

### 转为不同时间粒度

在上文中，我们转换时间时使用的是 ns （纳秒），最大程度地保留了最细的时间颗粒的供我们未来使用，但有时间我们不需要这么精确的细小粒度，如何操作呢？这就需要在 datetime64 后的括号里指定我们想要的粒度，如：

```python
# 一个时间文本序列
s = pd.Series(['2016-01-31 10:18:04', '2016-02-29 12:18:09'])
s
'''
0    2016-01-31 10:18:04
1    2016-02-29 12:18:09
dtype: object
'''

# 纳秒级
s.astype('datetime64[ns]')
'''
0   2016-01-31 10:18:04
1   2016-02-29 12:18:09
dtype: datetime64[ns]
'''
```

### M8 类型表示

在 `astype` 中还可以传入短字符串表示法 `<M8[ns]` 表示类型，M8 是 numpy.datetime64 的字符表示形式：

```python
s.astype('M8[ns]')
s.astype('<M8[ns]')
s.astype('<M8[ns]')
s.astype('M8')
'''
0   2016-01-31 10:18:04
1   2016-02-29 12:18:09
dtype: datetime64[ns]
'''

s.astype('M8[Y]')
'''
0   2016-01-01
1   2016-01-01
dtype: datetime64[ns]
'''

s.astype('datetime64[s]').dtype
# dtype('<M8[ns]')
```

`datetime64[ns]` 是通用数据类型，而 `<M8[ns]` 是一个特定的数据类型。一般 dtypes 映射到特定的 dtypes，但可能会因 NumPy 的一个安装而异。

在字节顺序为小端的机器上，`np.dtype('datetime64[ns]')` 和 `np.dtype('<M8[ns]')` 两者之间没有区别 ，然而，在大端机器上，`np.dtype('datetime64[ns]')` 等于 `np.dtype('>M8[ns]')`，所以 `datetime64[ns]` 映射到 `<M8[ns]` 或 `>M8[ns]` 取决于机器的字节序。还有许多其他类似的将通用数据类型映射到特定数据类型的示例:`int64`映射到 `<i8` 或 `>i`8 , 和 `int` 映射到 `int32` 或 `int64` 取决于操作系统的位架构以及 NumPy 的编译方式。

详见：[NumPy 的数据类型](https://www.gairuo.com/p/numpy-dtype)

### 转为时间 pd.to_datetime

Pandas 提供的 `pd.to_datetime()` 是识别转换时间的主要工具。接下来我们看一些例子。

从 DataFrame 的多个列中组合一个日期时间。 键可以是常见的缩写，例如['year'，'month'，'day'，'minute'，'second'，'ms'，'us'，'ns']）：

- 必须: year, month, day
- 可选: hour, minute, second, millisecond, microsecond, nanosecond

```python
df = pd.DataFrame({'year': [2015, 2016],
                   'month': [2, 3],
                   'day': [4, 5]})
df
'''
   year  month  day
0  2015      2    4
1  2016      3    5
'''
pd.to_datetime(df)
pd.to_datetime(df[['year', 'month', 'day']]) # 同上
'''
0   2015-02-04
1   2016-03-05
dtype: datetime64[ns]
'''
```

智能解析时间：

```python
pd.to_datetime(pd.Series(['Jul 31, 2009', '2010-01-10', None]))
'''
0   2009-07-31
1   2010-01-10
2          NaT
dtype: datetime64[ns]
'''

pd.to_datetime(['2005/11/23', '2010.12.31'])
# DatetimeIndex(['2005-11-23', '2010-12-31'], dtype='datetime64[ns]', freq=None)

pd.to_datetime(['04-01-2012 10:00'], dayfirst=True) # 日期在前
# DatetimeIndex(['2012-01-04 10:00:00'], dtype='datetime64[ns]', freq=None)
```

可以使用 `pd.Timestamp()` 进行转换：

```python
pd.to_datetime('2010/11/12')
# Timestamp('2010-11-12 00:00:00')

pd.Timestamp('2010/11/12')
# Timestamp('2010-11-12 00:00:00')
```

`pd.DatetimeIndex` 也可以转换：

```python
pd.DatetimeIndex(['2018-01-01', '2018-01-03', '2018-01-05'])
# DatetimeIndex(['2018-01-01', '2018-01-03', '2018-01-05'], dtype='datetime64[ns]', freq=None)

pd.DatetimeIndex(['2018-01-01', '2018-01-03', '2018-01-05'], freq='infer')
# DatetimeIndex(['2018-01-01', '2018-01-03', '2018-01-05'], dtype='datetime64[ns]', freq='2D')
```

对于有格式的数据，需要指定数据的格式：

```python
pd.to_datetime('13000101', format='%Y%m%d', errors='ignore')
# 可以让系统自己推断时间格式
pd.to_datetime('13000101', infer_datetime_format=True, errors='ignore')
# datetime.datetime(1300, 1, 1, 0, 0)
# coerce 将不会忽略错误，返回空值
pd.to_datetime('13000101', format='%Y%m%d', errors='coerce')
# NaT

# 有时间需要字段转为字符
pd.to_datetime(df.d.astype(str), format='%m/%d/%Y')

# 其他
pd.to_datetime('2010/11/12', format='%Y/%m/%d')
# Timestamp('2010-11-12 00:00:00')

pd.to_datetime('12-11-2010 00:00', format='%d-%m-%Y %H:%M')
# Timestamp('2010-11-12 00:00:00')
```

对时间戳进行转换，需要给出时间单位，一般为秒：

```python
pd.to_datetime(1490195805, unit='s')
# Timestamp('2017-03-22 15:16:45')
pd.to_datetime(1490195805433502912, unit='ns')
# Timestamp('2017-03-22 15:16:45.433502912')
```

对周期数据进行转换：

```python
pd.to_datetime([1, 2, 3], unit='D',
               origin=pd.Timestamp('1960-01-01'))
# DatetimeIndex(['1960-01-02', '1960-01-03', '1960-01-04'], dtype='datetime64[ns]', f
```

### 日期格式化符号

python中时间日期格式化符号：

- %y 两位数的年份表示（00-99）
- %Y 四位数的年份表示（000-9999）
- %m 月份（01-12）
- %d 月内中的一天（0-31）
- %H 24小时制小时数（0-23）
- %I 12小时制小时数（01-12）
- %M 分钟数（00-59）
- %S 秒（00-59）
- %a 本地简化星期名称
- %A 本地完整星期名称
- %b 本地简化的月份名称
- %B 本地完整的月份名称
- %c 本地相应的日期表示和时间表示
- %j 年内的一天（001-366）
- %p 本地A.M.或P.M.的等价符
- %U 一年中的星期数（00-53）星期天为星期的开始
- %w 星期（0-6），星期天为星期的开始
- %W 一年中的星期数（00-53）星期一为星期的开始
- %x 本地相应的日期表示
- %X 本地相应的时间表示
- %Z 当前时区的名称
- %% %号本身

### 参考

## 时间范围

### 生成时间范围

可以使用 `pd.DatetimeIndex()` 和 `pd.Index()` 来构造时间范围数据：

```python
import datetime
dates = [datetime.datetime(2012, 5, 1),
         datetime.datetime(2012, 5, 2),
         datetime.datetime(2012, 5, 3)]

# 无频率
pd.DatetimeIndex(dates)
pd.Index(dates) # 效果同上
'''
DatetimeIndex(['2012-05-01',
               '2012-05-02',
               '2012-05-03'],
              dtype='datetime64[ns]', freq=None)
'''
```

当然，可以解析时间格式：

```python
pd.date_range(start='1/1/2018', end='1/08/2018')
'''
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
               '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
              dtype='datetime64[ns]', freq='D')
'''
```

可以指定周期数：

```python
pd.date_range(start='1/1/2018', periods=8)
'''
DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
               '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],
              dtype='datetime64[ns]', freq='D')
'''
```

结尾指定周期后会向前生成：

```python
pd.date_range(end='1/1/2018', periods=8)
'''
DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',
               '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],
              dtype='datetime64[ns]', freq='D')
'''
```

如果开始、结束、周期都有指定，会自动按周期进行分隔：

```python
pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)
'''
DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',
               '2018-04-27 00:00:00'],
              dtype='datetime64[ns]', freq=None)
'''
```

`date_range` 的默认频率是 `D` 日，可以指定为其他频率，参见 [时间偏移别名](https://www.gairuo.com/p/pandas-offset-aliases)。

```python
# 指定频率为月
pd.date_range(start='1/1/2018', periods=5, freq='M')
DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',
               '2018-05-31'],
              dtype='datetime64[ns]', freq='M')
```

### 固定频率 [date_range](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.date_range.html?highlight=date_range#pandas.date_range)

在实际使用中，我们只需要给出开始和结束时间和频率，`pd.date_range` 系统会快速生成时间范围数据：

```python
start = datetime.datetime(2011, 1, 1)
end = datetime.datetime(2012, 1, 1)
pd.date_range(start, end)
'''
DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03', '2011-01-04',
               '2011-01-05', '2011-01-06', '2011-01-07', '2011-01-08',
               '2011-01-09', '2011-01-10',
               ...
               '2011-12-23', '2011-12-24', '2011-12-25', '2011-12-26',
               '2011-12-27', '2011-12-28', '2011-12-29', '2011-12-30',
               '2011-12-31', '2012-01-01'],
              dtype='datetime64[ns]', length=366, freq='D')
'''
```

多个单位频率：

```python
# 三个月
pd.date_range(start='1/1/2018', periods=5, freq='3M')
'''
DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
               '2019-01-31'],
              dtype='datetime64[ns]', freq='3M')
'''
```

频率也可以使用时间偏移：

```python
# 三个月，取月最后一天
pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))
'''
DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',
               '2019-01-31'],
              dtype='datetime64[ns]', freq='3M')
'''
```

可以指定时区：

```python
# 东京时间
pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')
'''
DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',
               '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',
               '2018-01-05 00:00:00+09:00'],
              dtype='datetime64[ns, Asia/Tokyo]', freq='D')
'''
```

`closed` 可以做开始和结束时间开闭区间的控制：

```python
# None 两边都包含
pd.date_range(start='2017-01-01', end='2017-01-04', closed=None)
'''
DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],
              dtype='datetime64[ns]', freq='D')

'''
# left 不包含右边
pd.date_range(start='2017-01-01', end='2017-01-04', closed='left')
'''
DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],
              dtype='datetime64[ns]', freq='D')
'''
# right 不包含左边
pd.date_range(start='2017-01-01', end='2017-01-04', closed='right')
'''
DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],
              dtype='datetime64[ns]', freq='D')
'''
```

### 工作日频率 [bdate_range](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.bdate_range.html?highlight=bdate_range#pandas.bdate_range)

`pd.bdate_range` 可以生成一个以工作日频率的日期范围，周末两天将会被跳过：

```python
pd.bdate_range(start='1/1/2021', end='1/08/2021')
'''
DatetimeIndex(['2021-01-01', '2021-01-04', '2021-01-05', '2021-01-06',
               '2021-01-07', '2021-01-08'],
              dtype='datetime64[ns]', freq='B')        
'''
pd.bdate_range(start=friday, end='2023-05-10', weekmask='1111110', holidays=None, freq='C')
'''
DatetimeIndex(['2023-04-28', '2023-04-29', '2023-05-01', '2023-05-02',
               '2023-05-03', '2023-05-04', '2023-05-05', '2023-05-06',
               '2023-05-08', '2023-05-09', '2023-05-10'],
              dtype='datetime64[ns]', freq='C')
'''
```

在四个参数中：开始，结束，周期和频率，必须精确指定三个。 指定频率是 `bdate_range` 的要求。 如果不需要指定频率，请使用 date_range。

### 频率

以上两个方法中都会要求传入频率，频率可以用时间偏移对象（DateOffset objects）的别名表示。详见 [时间偏移别名](https://www.gairuo.com/p/pandas-offset-aliases)。

## pandas 时间序列索引

### 时间索引切片

`DatetimeIndex` 作为时间索引，同样也支持数据切片：

```python
rng = pd.date_range('1/1/2021', '12/1/2021', freq='BM')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
'''
2021-01-29    0.216985
2021-02-26   -1.019431
2021-03-31    2.239779
2021-04-30    0.844563
2021-05-31   -0.637188
2021-06-30    0.813345
2021-07-30   -0.845968
2021-08-31    0.059855
2021-09-30    0.553753
2021-10-29    0.264783
2021-11-30    0.601772
Freq: BM, dtype: float64
'''
ts[2:4].index
# DatetimeIndex(['2021-03-31', '2021-04-30'], dtype='datetime64[ns]', freq='BM')
ts[::2].index
'''
DatetimeIndex(['2021-01-29', '2021-03-31', '2021-05-31', '2021-07-30',
               '2021-09-30', '2021-11-30'],
              dtype='datetime64[ns]', freq='2BM')
```

### 索引访问

以下是几种索引的访问方法：

```python
ts['1/29/2021']
# 0.21698543731135092
ts[datetime.datetime(2021, 9, 30):]
'''
2021-09-30    0.553753
2021-10-29    0.264783
2021-11-30    0.601772
Freq: BM, dtype: float64
'''
ts['5/31/2021':'8/31/2021']
'''
2021-05-31   -0.637188
2021-06-30    0.813345
2021-07-30   -0.845968
2021-08-31    0.059855
Freq: BM, dtype: float64
'''
```

也可以使用部分字符查询一定范围的数据：

```python
ts['2021'] # 查询整个2021年的
ts['2021-6'] # 查询 2021年6月的
ts['2021-6':'2021-10'] # 6月到10月的
dft['2013-1':'2013-2-28 00:00:00'] # 精确时间
dft['2013-1-15':'2013-1-15 12:30:00']
dft2.loc['2013-01-05']
# 索引选择器
idx = pd.IndexSlice
dft2.loc[idx[:, '2013-01-05'], :]
# 带时区，原数据时区可能不是这个
df['2019-01-01 12:00:00+04:00':'2019-01-01 13:00:00+04:00']
```

### 频率的分辨率（粒度）

在之前的例子中我们看到频率有工作日的，有自然日的，但它们都是以日为单位的，所以日就是他们有的相同的分辨率，也就是最小粒度。可以使用 `x.resolution` 查看频率的分辨率。

```python
series_minute = pd.Series([1, 2, 3],
                          pd.DatetimeIndex(['2011-12-31 23:59:00',
                                            '2012-01-01 00:00:00',
                                            '2012-01-01 00:02:00']))
series_minute.index.resolution
# 'minute'
# 按小时取出
series_minute['2011-12-31 23']
'''
2011-12-31 23:59:00    1
dtype: int64
'''
series_minute['2011-12-31 23:59']
# 1
series_minute['2011-12-31 23:59:00']
# 1
```

另一个例子：

```python
series_second = pd.Series([1, 2, 3],
                          pd.DatetimeIndex(['2011-12-31 23:59:59',
                                            '2012-01-01 00:00:00',
                                            '2012-01-01 00:00:01']))
# 最小粒度为秒
series_second.index.resolution
# 'second'
series_second['2011-12-31 23:59']
'''
2011-12-31 23:59:59    1
dtype: int64
'''
```

### 截断索引

`df.truncate()` 作为一个专门对索引的截取工具，可以很好地应用在时序索引上：

```python
rng2 = pd.date_range('2011-01-01', '2012-01-01', freq='W')
ts2 = pd.Series(np.random.randn(len(rng2)), index=rng2)
ts2.truncate(before='2011-11', after='2011-12')
'''
2011-11-06    0.437823
2011-11-13   -0.293083
2011-11-20   -0.059881
2011-11-27    1.252450
Freq: W-SUN, dtype: float64
'''
# 对比以上操作的不同
ts2['2011-11':'2011-12']
'''
2011-11-06    0.437823
2011-11-13   -0.293083
2011-11-20   -0.059881
2011-11-27    1.252450
2011-12-04    0.046611
2011-12-11    0.059478
2011-12-18   -0.286539
2011-12-25    0.841669
Freq: W-SUN, dtype: float64
'''

# 也可以通过自然索引来取
ts2[[0, 2, 6]].index
```

其他类型数据的使用例子：

```python
df = pd.DataFrame({'A': ['a', 'b', 'c', 'd', 'e'],
                   'B': ['f', 'g', 'h', 'i', 'j'],
                   'C': ['k', 'l', 'm', 'n', 'o']},
                  index=[1, 2, 3, 4, 5])
df
'''
   A  B  C
1  a  f  k
2  b  g  l
3  c  h  m
4  d  i  n
5  e  j  o
'''
df.truncate(before=2, after=4)
'''
   A  B  C
2  b  g  l
3  c  h  m
4  d  i  n
'''
# 按列取
df.truncate(before="A", after="B", axis="columns")
'''
   A  B
1  a  f
2  b  g
3  c  h
4  d  i
5  e  j
'''
df['A'].truncate(before=2, after=4)
'''
2    b
3    c
4    d
Name: A, dtype: object
'''
```

截取时间的例子：

```python
dates = pd.date_range('2016-01-01', '2016-02-01', freq='s')
df = pd.DataFrame(index=dates, data={'A': 1})
df.tail()
'''
                     A
2016-01-31 23:59:56  1
2016-01-31 23:59:57  1
2016-01-31 23:59:58  1
2016-01-31 23:59:59  1
2016-02-01 00:00:00  1
'''
df.truncate(before=pd.Timestamp('2016-01-05'),
            after=pd.Timestamp('2016-01-10')).tail()
'''
                     A
2016-01-09 23:59:56  1
2016-01-09 23:59:57  1
2016-01-09 23:59:58  1
2016-01-09 23:59:59  1
2016-01-10 00:00:00  1
'''
df.truncate('2016-01-05', '2016-01-10').tail()
'''
                     A
2016-01-09 23:59:56  1
2016-01-09 23:59:57  1
2016-01-09 23:59:58  1
2016-01-09 23:59:59  1
2016-01-10 00:00:00  1
'''
df.loc['2016-01-05':'2016-01-10', :].tail()
'''
                     A
2016-01-10 23:59:55  1
2016-01-10 23:59:56  1
2016-01-10 23:59:57  1
2016-01-10 23:59:58  1
2016-01-10 23:59:59  1
'''
```

## 时序方法

### 移动 Shifting

可能需要将时间序列中的值在时间上前后移动或滞后。 shift() 方法也可以在时序对象上使用。

```python
rng = pd.date_range('2020-06-01', '2020-06-03')
ts = pd.Series(range(len(rng)), index=rng)
ts
'''
2020-06-01    0
2020-06-02    1
2020-06-03    2
Freq: D, dtype: int64
'''
ts.shift(1)
'''
2020-06-01    NaN
2020-06-02    0.0
2020-06-03    1.0
Freq: D, dtype: float64
'''
```

shift 方法接受 freq 参数，该参数可以接受 DateOffset 类或其他类似 timedelta 的对象，也可以接受[偏移别名](https://www.gairuo.com/p/pandas-offset-aliases)：

```python
# 工作日
ts.shift(3, freq=pd.offsets.BDay())
'''
2020-06-04    0
2020-06-05    1
2020-06-08    2
Freq: B, dtype: int64
'''
# 工作日月末
ts.shift(3, freq='BM')
'''
2020-08-31    0
2020-08-31    1
2020-08-31    2
Freq: D, dtype: int64
'''
```

除了更改数据和索引的对齐方式之外，DataFrame和Series对象还具有 tshift() 便捷方法，该方法将索引中的所有日期更改指定的偏移量（只移动索引）：

```python
ts.tshift(3, freq='D')
'''
2020-06-04    0
2020-06-05    1
2020-06-06    2
Freq: D, dtype: int64
'''
```

请注意，使用tshift时，最前边的 条目将不再是NaN，因为不会重新对齐数据。

除了更改数据和索引的对齐方式之外，DataFrame和Series对象还具有 tshift() 便捷方法，该方法将索引中的所有日期更改指定的偏移量（只移动索引）：

```python
ts.tshift(3, freq='D')
'''
2020-06-04    0
2020-06-05    1
2020-06-06    2
Freq: D, dtype: int64
'''
```

请注意，使用tshift时，最前边的 条目将不再是NaN，因为不会重新对齐数据。

### 频率转换

更改频率的主要功能是 asfreq() 方法。

```python
dr = pd.date_range('1/1/2023', periods=3, freq=3 * pd.offsets.BDay())
ts = pd.Series(np.random.randn(3), index=dr)
ts
'''
2010-01-01    0.896958
2010-01-06   -1.571894
2010-01-11    1.886263
Freq: 3B, dtype: float64
'''
# 从3个工作日转为一个工作日
ts.asfreq(pd.offsets.BDay())
'''
2010-01-01    1.069063
2010-01-04         NaN
2010-01-05         NaN
2010-01-06    0.784018
2010-01-07         NaN
2010-01-08         NaN
2010-01-11    0.490291
Freq: B, dtype: float64
'''
```

asfreq 提供了更多便利，因此您可以为频率转换后可能出现的任何间隙指定插值方法。

```python
ts.asfreq(pd.offsets.BDay(), method='pad')
'''
2010-01-01    1.069063
2010-01-04    1.069063
2010-01-05    1.069063
2010-01-06    0.784018
2010-01-07    0.784018
2010-01-08    0.784018
2010-01-11    0.490291
Freq: B, dtype: float64
'''
# 对空值进行填充
ts.asfreq(freq='30S', fill_value=9.0)
```

对于 DatetimeIndex，这基本上只是reindex() 的一个很方便的包装器，该包装器生成 date_range 并调用 reindex。

```python
date_index = pd.date_range('1/1/2010', periods=6, freq='D')
df2 = pd.DataFrame({"prices": [100, 101, np.nan, 100, 89, 88]},
                   index=date_index)
df2
'''
            prices
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0
'''

# 假设我们决定扩展数据框以覆盖更大的日期范围
date_index2 = pd.date_range('12/29/2009', periods=10, freq='D')
df2.reindex(date_index2)
'''
            prices
2009-12-29     NaN
2009-12-30     NaN
2009-12-31     NaN
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0
2010-01-07     NaN
'''
```

默认情况下，原始数据框中没有值的索引条目（例如，“ 2009-12-29”）将用NaN填充。 如果需要，我们可以使用几个选项之一（{None, ‘backfill’/’bfill’, ‘pad’/’ffill’, ‘nearest’}）来填写缺失值。

例如，要反向传播最后一个有效值以填充NaN值，请将 bfill 作为参数传递给method关键字。

```python
df2.reindex(date_index2, method='bfill')
'''
            prices
2009-12-29   100.0
2009-12-30   100.0
2009-12-31   100.0
2010-01-01   100.0
2010-01-02   101.0
2010-01-03     NaN
2010-01-04   100.0
2010-01-05    89.0
2010-01-06    88.0
2010-01-07     NaN
'''
```

### 其他方法

## 时间偏移

### 理解 DateOffset 对象

DateOffset 类似于时间差 Timedelta ，但它使用日历中时间日期的规则，而不是直接进行时间性质的算术计算，让时间更符合实际生活。比如，有些地区使用夏令时时，每日偏移时间有可能是 23 或 24 小时，甚至 25 个小时。

### DateOffset 示例

以下所示了夏令时的情况：

```python
# 生成一个指定的时间，芬兰赫尔辛基时间执行夏令时
ts = pd.Timestamp('2016-10-30 00:00:00', tz='Europe/Helsinki')

ts
# Timestamp('2016-10-30 00:00:00+0300', tz='Europe/Helsinki')

# 增加一天
ts + pd.Timedelta(days=1)
# Timestamp('2016-10-30 23:00:00+0200', tz='Europe/Helsinki')

# 按日历时间
ts + pd.DateOffset(days=1)
# Timestamp('2016-10-31 00:00:00+0200', tz='Europe/Helsinki')
```

以下是增加工作日，出现跨周末的情况：

```python
friday = pd.Timestamp('2018-01-05')
friday.day_name()
#'Friday'

# 增加两个工作日，从周五到周二
two_business_days = 2 * pd.offsets.BDay()
two_business_days.apply(friday)
# Timestamp('2018-01-09 00:00:00')

friday + two_business_days
# Timestamp('2018-01-09 00:00:00')

(friday + two_business_days).day_name()
# 'Tuesday'
```

## 时间偏移对象

Pandas 专门提供了一个时间偏移对象（Date offsets）来完成时间偏移工作，本文将介绍 Date offsets 的构成和使用方法。DateOffset 基础操作类似于 `dateutil.relativedelta`（[relativedelta 文档](https://dateutil.readthedocs.io/en/stable/relativedelta.html)），可以按真实的日历进行时间偏移，并用算数运算符（+）或 apply 进行日期偏移操作。

## offsets 对象

所有的日期偏移对象都在 `pandas.tseries.offsets` 下，其中 `pandas.tseries.offsets.DateOffset` 是标准的日期范围时间偏移类型，用于日期范围的标准日期增量类型。它默认是一个日历日。

```python
from pandas.tseries.offsets import DateOffset
ts = pd.Timestamp('2017-01-01 09:10:11')
ts + DateOffset(months=3)
# Timestamp('2017-04-01 09:10:11')
ts + DateOffset(hours=2)
# Timestamp('2017-01-01 11:10:11')
ts + DateOffset()
# Timestamp('2017-01-02 09:10:11')
```

### 频率字符串

DateOffset 基本都支持频率字符串或偏移别名，传入 freq 参数。以下都是时间偏移的子类、子对象，都支持时间偏移的相关操作。有效的日期偏移及频率字符串有：

| 日期偏移对象                             | 频率字符串    | 说明                                       |
| ---------------------------------------- | ------------- | ------------------------------------------ |
| DateOffset                               | 无            | 通用偏移类，默认一个日历日                 |
| BDay 或 BusinessDay                      | 'B'           | 工作日                                     |
| CDay 或 CustomBusinessDay                | 'C'           | 自定义工作日                               |
| Week                                     | 'W'           | 一周，可选周内固定某日                     |
| WeekOfMonth                              | 'WOM'         | 每月第几周的第几天                         |
| LastWeekOfMonth                          | 'LWOM'        | 每月最后一周的第几天                       |
| MonthEnd                                 | 'M'           | 日历日月末                                 |
| MonthBegin                               | 'MS'          | 日历日月初                                 |
| BMonthEnd 或 BusinessMonthEnd            | 'BM'          | 工作日月末                                 |
| BMonthBegin 或 BusinessMonthBegin        | 'BMS'         | 工作日月初                                 |
| CBMonthEnd 或 CustomBusinessMonthEnd     | 'CBM'         | 自定义工作日月末                           |
| CBMonthBegin 或 CustomBusinessMonthBegin | 'CBMS'        | 自定义工作日月初                           |
| SemiMonthEnd                             | 'SM'          | 某月第 15 天（或其它半数日期）与日历日月末 |
| SemiMonthBegin                           | 'SMS'         | 日历日月初与第 15 天（或其它半数日期）     |
| QuarterEnd                               | 'Q'           | 日历日季末                                 |
| QuarterBegin                             | 'QS'          | 日历日季初                                 |
| BQuarterEnd                              | 'BQ           | 工作日季末                                 |
| BQuarterBegin                            | 'BQS'         | 工作日季初                                 |
| FY5253Quarter                            | 'REQ'         | 零售季，又名 52-53 周                      |
| YearEnd                                  | 'A'           | 日历日年末                                 |
| YearBegin                                | 'AS' 或 'BYS' | 日历日年初                                 |
| BYearEnd                                 | 'BA'          | 工作日年末                                 |
| BYearBegin                               | 'BAS'         | 工作日年初                                 |
| FY5253                                   | 'RE'          | 零售年（又名 52-53 周）                    |
| Easter                                   | 无            | 复活节假日                                 |
| BusinessHour                             | 'BH'          | 工作小时                                   |
| CustomBusinessHour                       | 'CBH'         | 自定义工作小时                             |
| Day                                      | 'D'           | 一天                                       |
| Hour                                     | 'H'           | 一小时                                     |
| Minute                                   | 'T' 或 'min'  | 一分钟                                     |
| Second                                   | 'S'           | 一秒                                       |
| Milli                                    | 'L' 或 'ms'   | 一毫秒                                     |
| Micro                                    | 'U' 或 'us'   | 一微秒                                     |
| Nano                                     | 'N'           | 一纳秒                                     |

### 移动偏移

Offset 支持向前或向后偏移：

```python
ts = pd.Timestamp('2020-06-06 00:00:00')
ts.day_name()
# 'Saturday'

# 定义一个工作小时偏移，默认是周一到周五 9-17 点，我们从 10点开始
offset = pd.offsets.BusinessHour(start='10:00')

# 向前偏移一个工作小时，是一个周一，跳过了周日
offset.rollforward(ts)
# Timestamp('2020-06-08 10:00:00')

# 向前偏移至最近的工作日，小时也会增加
ts + offset
# Timestamp('2020-06-08 11:00:00')

# 向后偏移，会在周五下班前的一个小时
offset.rollback(ts)
# Timestamp('2020-06-05 17:00:00')

ts - pd.offsets.Day(1) # 昨日
ts - pd.offsets.Day(2) # 前日
ts - pd.offsets.Week(weekday=0) - pd.offsets.Day(14) # 上周一
ts - pd.offsets.MonthEnd() - pd.offsets.MonthBegin() # 上月一日
```

时间偏移操作会保留小时和分钟，有时候我们不在意具体的时间只开始从哪天开始，可以使用 `normalize()` 进行标准化到午夜 0 点：

```python
offset.rollback(ts).normalize()
# Timestamp('2020-06-05 00:00:00')
```

### 应用偏移

`apply` 可以使用偏移对象应用到一个时间上：

```python
ts = pd.Timestamp('2020-06-01 09:00')
day = pd.offsets.Day() # 定义偏移对象
day.apply(ts) # 偏移对象应用到时间上
# Timestamp('2020-06-02 09:00:00')
day.apply(ts).normalize() # 标准化/归一化
# Timestamp('2020-06-02 00:00:00')

ts = pd.Timestamp('2020-06-01 22:00')
hour = pd.offsets.Hour()
hour.apply(ts)
# Timestamp('2020-06-01 23:00:00')

hour.apply(ts).normalize()
# Timestamp('2020-06-01 00:00:00')

hour.apply(pd.Timestamp("2014-01-01 23:30")).normalize()
# Timestamp('2014-01-02 00:00:00')
```

### 偏移参数

上边我们偏移时只偏移了偏移对象的一个单位，可以传入参数支持多个单位和对象中的其他单位：

```python
import datetime
d = datetime.datetime(2020, 6, 1, 9, 0)
# datetime.datetime(2020, 6, 1, 9, 0)

d + pd.offsets.Week() # 偏移一周
# Timestamp('2020-06-08 09:00:00')

d + pd.offsets.Week(weekday=4) # 偏移4个周中的日期
# Timestamp('2020-06-05 09:00:00')

# 取一周第几天
(d + pd.offsets.Week(weekday=4)).weekday()
# 4

d - pd.offsets.Week() # 向后一周
# Timestamp('2020-05-25 09:00:00')
```

参数也支持归一标准化 `normalize`:

```python
d + pd.offsets.Week(normalize=True)
# Timestamp('2020-06-08 00:00:00')

d - pd.offsets.Week(normalize=True)
# Timestamp('2020-05-25 00:00:00')
```

再比如，`YearEnd` 支持 `month` 指定月份：

```python
d + pd.offsets.YearEnd()
# Timestamp('2020-12-31 09:00:00')

d + pd.offsets.YearEnd(month=6)
# Timestamp('2020-06-30 09:00:00')
```

不同的偏移对象支持不同的参数，可以通过代码编辑器的代码提示进行查询。

### 相关查询

当使用日期作为索引的DataFrame时，此函数可以基于日期偏移量选择最后几行：

```python
i = pd.date_range('2018-04-09', periods=4, freq='2D')
ts = pd.DataFrame({'A': [1, 2, 3, 4]}, index=i)
ts
'''
            A
2018-04-09  1
2018-04-11  2
2018-04-13  3
2018-04-15  4
'''

# 取最后三天, 请注意，返回的是最近3天的数据
# 而不是数据集中最近3天的数据，因此未返回2018-04-11的数据
ts.last('3D')
'''
            A
2018-04-13  3
2018-04-15  4
'''

# 前三天
ts.first('3D')
'''
            A
2018-04-09  1
2018-04-11  2
'''

# 指定时间
ts.at_time('12:00')
'''
                     A
2018-04-09 12:00:00  2
2018-04-10 12:00:00  4
'''

ts.between_time('0:15', '0:45')
'''
                     A
2018-04-10 00:20:00  2
2018-04-11 00:40:00  3
'''

ts.between_time('0:45', '0:15')
'''
                     A
2018-04-09 00:00:00  1
2018-04-12 01:00:00  4
'''
```

## 序列、索引和时间偏移

### 序列与时间偏移操作

```python
rng = pd.date_range('2012-01-01', '2012-01-03')
s = pd.Series(rng)
rng
# DatetimeIndex(['2012-01-01', '2012-01-02', '2012-01-03'], dtype='datetime64[ns]', freq='D')
s
'''
0   2012-01-01
1   2012-01-02
2   2012-01-03
dtype: datetime64[ns]
'''

rng + pd.DateOffset(months=2)
# DatetimeIndex(['2012-03-01', '2012-03-02', '2012-03-03'], dtype='datetime64[ns]', freq='D')

s + pd.DateOffset(months=2)
'''
0   2012-03-01
1   2012-03-02
2   2012-03-03
dtype: datetime64[ns]
'''

s - pd.DateOffset(months=2)
'''
0   2011-11-01
1   2011-11-02
2   2011-11-03
dtype: datetime64[ns]
'''
```

### 与时长的操作

时长也支持与时间偏移进行操作，而且和时长与时长的操作一样：

```python
s - pd.offsets.Day(2)
'''
0   2011-12-30
1   2011-12-31
2   2012-01-01
dtype: datetime64[ns]
'''

td = s - pd.Series(pd.date_range('2011-12-29', '2011-12-31'))
td
''' 
0   3 days
1   3 days
2   3 days
dtype: timedelta64[ns]
'''

td + pd.offsets.Minute(15)
'''
0   3 days 00:15:00
1   3 days 00:15:00
2   3 days 00:15:00
dtype: timedelta64[ns]
'''
```

需要注意的是，有些时间偏移对象不支持以上操作，还有是就算支持性能会很差，执行很慢，会及抛出性能警告。

## 自定义工作日

### 自定义工作日

`Cday` 或 `CustomBusinessDay` 类可以传入节假日参数来自定义一个工作日偏移对象：

```python
weekmask_egypt = 'Sun Mon Tue Wed Thu'

# 定义出五一劳动节的日期，因为放假
holidays = ['2012-05-01',
            datetime.datetime(2013, 5, 1),
            np.datetime64('2014-05-01')]

# 自定义工作日中传入休假日期，一个正常星期工作日的顺序
bday_egypt = pd.offsets.CustomBusinessDay(holidays=holidays,
                                          weekmask=weekmask_egypt)


# 指定一个日期
dt = datetime.datetime(2013, 4, 30)
# 偏移两个工作日，跳过了五一个休假日
dt + 2 * bday_egypt
# Timestamp('2013-05-05 00:00:00')
```

可以将日期的具体星期匹配映射出来：

```python
dts = pd.date_range(dt, periods=5, freq=bday_egypt)
(
    pd.Series(dts.weekday, dts)
    .map(pd.Series('Mon Tue Wed Thu Fri Sat Sun'.split()))
)
'''
2013-04-30    Tue
2013-05-02    Thu
2013-05-05    Sun
2013-05-06    Mon
2013-05-07    Tue
Freq: C, dtype: object
'''
```

### 节假日日历

Pandas 内置了一些常用的节假日日历：

```python
# 美国佛罗里达州的节假日
from pandas.tseries.holiday import USFederalHolidayCalendar

bday_us = pd.offsets.CustomBusinessDay(calendar=USFederalHolidayCalendar())

# 马丁路德金纪念日前是周五
dt = datetime.datetime(2014, 1, 17)

# 马丁路德金纪念日后为周二，周一放假，跳过
dt + bday_us
# Timestamp('2014-01-21 00:00:00')
```

### 频率使用

可以在时序数据频率中使用：

```python
bmth_us = pd.offsets.CustomBusinessMonthBegin(calendar=USFederalHolidayCalendar())
dt = datetime.datetime(2013, 12, 17)
# 跳过元旦
dt + bmth_us
# Timestamp('2014-01-02 00:00:00')

# 频率中应用自定义工作偏移
pd.date_range(start='20100101', end='20120101', freq=bmth_us)
'''
DatetimeIndex(['2010-01-04', '2010-02-01', '2010-03-01', '2010-04-01',
               '2010-05-03', '2010-06-01', '2010-07-01', '2010-08-02',
               '2010-09-01', '2010-10-01', '2010-11-01', '2010-12-01',
               '2011-01-03', '2011-02-01', '2011-03-01', '2011-04-01',
               '2011-05-02', '2011-06-01', '2011-07-01', '2011-08-01',
               '2011-09-01', '2011-10-03', '2011-11-01', '2011-12-01'],
              dtype='datetime64[ns]', freq='CBMS')
'''
```

注：频率字符串“ C”用于表示已使用 CustomBusinessDay DateOffset，由于CustomBusinessDay 是参数化类型，因此 CustomBusinessDay 的实例可能会有所不同，并且无法从 “ C” 频率字符串中检测到。 因此，需要确保在用户的应用程序中始终使用“ C”频率字符串。

### 工作时间

`BusinessHour` 表是开始和结束工作的小时时间，默认的工作时间是 9:00 - 17:00，与时间相加超过一个小时会移到下一个小时，超过一天会移动到下一个工作日。

```
bh = pd.offsets.BusinessHour()
bh
# <BusinessHour: BH=09:00-17:00>

# 2014-08-01 是周五
pd.Timestamp('2014-08-01 10:00').weekday()
# 4

# 增加一个工作小时
pd.Timestamp('2014-08-01 10:00') + bh
# Timestamp('2014-08-01 11:00:00')

# 一但计算就等于上班了，等同于 pd.Timestamp('2014-08-01 09:00') + bh
pd.Timestamp('2014-08-01 08:00') + bh
# Timestamp('2014-08-01 10:00:00')

# 计算后已经下班了，就移到下一个工作小时（跳过周末）
pd.Timestamp('2014-08-01 16:00') + bh
Out[205]: Timestamp('2014-08-04 09:00:00')

# 同上逻辑，移动一个工作小时
pd.Timestamp('2014-08-01 16:30') + bh
Out[206]: Timestamp('2014-08-04 09:30:00')

# 偏移两个工作小时
pd.Timestamp('2014-08-01 10:00') + pd.offsets.BusinessHour(2)
# Timestamp('2014-08-01 12:00:00')

# 减去3个工作小时
pd.Timestamp('2014-08-01 10:00') + pd.offsets.BusinessHour(-3)
# Timestamp('2014-07-31 15:00:00')
```

可以自己定义开始和结束工作的时间，格式必须是 `hour:minute` 字符串，不支持秒、微秒、纳秒，会报错，因为工作时间没有定这么细的，可能。

```python
# 11点开始上班
bh = pd.offsets.BusinessHour(start='11:00', end=datetime.time(20, 0))
bh
# <BusinessHour: BH=11:00-20:00>

pd.Timestamp('2014-08-01 13:00') + bh
# Timestamp('2014-08-01 14:00:00')

pd.Timestamp('2014-08-01 09:00') + bh
# Timestamp('2014-08-01 12:00:00')

pd.Timestamp('2014-08-01 18:00') + bh
# Timestamp('2014-08-01 19:00:00')
```

start 时间晚于 end 时间表示夜班工作时间。此时，工作时间将从午夜延至第二天。

```python
bh = pd.offsets.BusinessHour(start='17:00', end='09:00')
bh
# <BusinessHour: BH=17:00-09:00>

pd.Timestamp('2014-08-01 17:00') + bh
# Timestamp('2014-08-01 18:00:00')

pd.Timestamp('2014-08-01 23:00') + bh
# Timestamp('2014-08-02 00:00:00')

# 尽管 2014 年 8 月 2 日是周六，
# 但因为工作时间周五开始，因此也有效
pd.Timestamp('2014-08-02 04:00') + bh
# Timestamp('2014-08-02 05:00:00')

# 虽然 2014 年 8 月 4 日是周一，
# 但开始时间是周日，超出了工作时间
pd.Timestamp('2014-08-04 04:00') + bh
# Timestamp('2014-08-04 18:00:00')
```

## 自定义工作时间

`CustomBusinessHour` 是 `BusinessHour` 和 `CustomBusinessDay` 的混合体，可以指定任意节假日。 `CustomBusinessHour` 与 `BusinessHour` 的工作原理相同，只是它跳过指定的自定义假日。

```python
from pandas.tseries.holiday import USFederalHolidayCalendar
bhour_us = pd.offsets.CustomBusinessHour(calendar=USFederalHolidayCalendar())

# 马丁路德金纪念日之前的周五
dt = datetime.datetime(2014, 1, 17, 15)
dt + bhour_us
Timestamp('2014-01-17 16:00:00')

# 跳至马丁路德金纪念日之后的周二，周一放假，跳过
In [229]: dt + bhour_us * 2
Out[229]: Timestamp('2014-01-21 09:00:00')
```

您可以使用 `BusinessHour` 和 `CustomBusinessDay` 支持的关键字参数。

```python
bhour_mon = pd.offsets.CustomBusinessHour(start='10:00',
                                          weekmask='Tue Wed Thu Fri')

# 周一是节日，跳过，工作时间从 10 点开始
dt + bhour_mon * 2
Timestamp('2014-01-21 10:00:00')
```

## 时间偏移量别名

### 偏移量别名

偏移量别名可以做为频率传入，如 `freq='M'`。

| 别名     | 说明                 |
| -------- | -------------------- |
| B        | 工作日               |
| C        | 自定义工作日         |
| D        | 日历日               |
| W        | 周频                 |
| M        | 月末                 |
| SM       | 半月末（15日与月末） |
| BM       | 工作日月末           |
| CBM      | 自定义工作日月末     |
| MS       | 月初                 |
| SMS      | 半月初（1日和15日）  |
| BMS      | 工作日月初           |
| CBMS     | 自定义工作日月初     |
| Q        | 季末                 |
| BQ       | 工作日季末           |
| QS       | 季初                 |
| BQS      | 工作日季初           |
| A, Y     | 年末                 |
| BA, BY   | 工作日年末           |
| AS, YS   | 年初                 |
| BAS, BYS | 工作日年初           |
| BH       | 工作时间（小时级）   |
| H        | 小时                 |
| T, min   | 分钟                 |
| S        | 秒                   |
| L, ms    | 毫秒                 |
| U, us    | 微秒                 |
| N        | 纳秒                 |

注：

- 加 S 表示当周期的第一天，默认为结束
- 半年可使用 2QS（自然年的前半年和后半年）或者 6MS（6个自然月），其他的类似

### 别名使用

别名可以用在大多数函数的频率中：

```python
pd.date_range('2020-06-01', periods=5, freq=pd.offsets.BDay())
# 用别名替代
pd.date_range('2020-06-01', periods=5, freq='B')
'''
DatetimeIndex(['2020-06-01', '2020-06-02', '2020-06-03', '2020-06-04',
               '2020-06-05'],
              dtype='datetime64[ns]', freq='B')
'''
```

### 组合别名

可以将日内偏移量组合在一起：

```python
# 两小时20分
pd.date_range('20200601', periods=10, freq='2h20min')
'''
DatetimeIndex(['2020-06-01 00:00:00', '2020-06-01 02:20:00',
               '2020-06-01 04:40:00', '2020-06-01 07:00:00',
               '2020-06-01 09:20:00', '2020-06-01 11:40:00',
               '2020-06-01 14:00:00', '2020-06-01 16:20:00',
               '2020-06-01 18:40:00', '2020-06-01 21:00:00'],
              dtype='datetime64[ns]', freq='140T')
'''

# 一天10微秒
pd.date_range('20200601', periods=10, freq='1D10U')
'''
DatetimeIndex(['2020-06-01 00:00:00', '2020-06-02 00:00:00.000010',
               '2020-06-03 00:00:00.000020', '2020-06-04 00:00:00.000030',
               '2020-06-05 00:00:00.000040', '2020-06-06 00:00:00.000050',
               '2020-06-07 00:00:00.000060', '2020-06-08 00:00:00.000070',
               '2020-06-09 00:00:00.000080', '2020-06-10 00:00:00.000090'],
              dtype='datetime64[ns]', freq='86400000010U')
'''
```

## 锚定偏移

对于某些频率，可以指定锚定后缀，让它支持在一定有时间开始或结束。比如我们可以把周频率从默认的周日调到周一 `'W-MON'`。

### 锚定偏移别名

| 别名        | 说明                   |
| ----------- | ---------------------- |
| W-SUN       | 周（星期日）同'W'      |
| W-MON       | 周（星期一）           |
| W-TUE       | 周（星期二）           |
| W-WED       | 周（星期三）           |
| W-THU       | 周（星期四）           |
| W-FRI       | 周（星期五）           |
| W-SAT       | 周（星期六）           |
| (B)Q(S)-DEC | 季，结束于12月，同 “Q” |
| (B)Q(S)-JAN | 季，结束于1月          |
| (B)Q(S)-FEB | 季，结束于2月          |
| (B)Q(S)-MAR | 季，结束于3月          |
| (B)Q(S)-APR | 季，结束于4月          |
| (B)Q(S)-MAY | 季，结束于5月          |
| (B)Q(S)-JUN | 季，结束于6月          |
| (B)Q(S)-JUL | 季，结束于7月          |
| (B)Q(S)-AUG | 季，结束于8月          |
| (B)Q(S)-SEP | 季，结束于9月          |
| (B)Q(S)-OCT | 季，结束于10月         |
| (B)Q(S)-NOV | 季，结束于11月         |
| (B)A(S)-DEC | 年，结束于12月，同 “A” |
| (B)A(S)-JAN | 年，结束于1月          |
| (B)A(S)-FEB | 年，结束于2月          |
| (B)A(S)-MAR | 年，结束于3月          |
| (B)A(S)-APR | 年，结束于4月          |
| (B)A(S)-MAY | 年，结束于5月          |
| (B)A(S)-JUN | 年，结束于6月          |
| (B)A(S)-JUL | 年，结束于7月          |
| (B)A(S)-AUG | 年，结束于8月          |
| (B)A(S)-SEP | 年，结束于9月          |
| (B)A(S)-OCT | 年，结束于10月         |
| (B)A(S)-NOV | 年，结束于11月         |

### 锚定偏移量移动

对于固定在特定频率开始或结束（monthhend、MonthBegin、WeekEnd等）的偏移，以下规则适用于向前和向后滚动:

当n不为0时，如果给定日期不在锚点上，则它会捕捉到下一个（上一个）锚点，并向前或向后移动 |n|-1 步。

```python
pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=1)
# Timestamp('2014-02-01 00:00:00')

pd.Timestamp('2014-01-02') + pd.offsets.MonthEnd(n=1)
# Timestamp('2014-01-31 00:00:00')

pd.Timestamp('2014-01-02') - pd.offsets.MonthBegin(n=1)
Out[238]: Timestamp('2014-01-01 00:00:00')

pd.Timestamp('2014-01-02') - pd.offsets.MonthEnd(n=1)
# Timestamp('2013-12-31 00:00:00')

pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=4)
# Timestamp('2014-05-01 00:00:00')

pd.Timestamp('2014-01-02') - pd.offsets.MonthBegin(n=4)
# Timestamp('2013-10-01 00:00:00')
```

如果给定的日期在锚点上，则将其| n |移动。 指向前进或后退：

```python
pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=1)
# Timestamp('2014-02-01 00:00:00')

pd.Timestamp('2014-01-31') + pd.offsets.MonthEnd(n=1)
# Timestamp('2014-02-28 00:00:00')

pd.Timestamp('2014-01-01') - pd.offsets.MonthBegin(n=1)
# Timestamp('2013-12-01 00:00:00')

pd.Timestamp('2014-01-31') - pd.offsets.MonthEnd(n=1)
# Timestamp('2013-12-31 00:00:00')

pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=4)
# Timestamp('2014-05-01 00:00:00')

pd.Timestamp('2014-01-31') - pd.offsets.MonthBegin(n=4)
# Timestamp('2013-10-01 00:00:00')
```

对于n = 0的情况，如果在锚点上，则日期不会移动，否则它将前滚到下一个锚点。

```python
pd.Timestamp('2014-01-02') + pd.offsets.MonthBegin(n=0)
# Timestamp('2014-02-01 00:00:00')

pd.Timestamp('2014-01-02') + pd.offsets.MonthEnd(n=0)
# Timestamp('2014-01-31 00:00:00')

pd.Timestamp('2014-01-01') + pd.offsets.MonthBegin(n=0)
# Timestamp('2014-01-01 00:00:00')

pd.Timestamp('2014-01-31') + pd.offsets.MonthEnd(n=0)
# Timestamp('2014-01-31 00:00:00')
```

## 假期日历

### 固定日期的假日

对于在固定日期（例如，美国阵亡将士纪念日或7月4日）发生的假日，遵守规则将确定该假日是在周末还是其他未观察到的日子进行观察。 定义的遵守规则是：

| 规则                   | 说明                                            |
| ---------------------- | ----------------------------------------------- |
| nearest_workday        | 把星期六移至星期五，星期日移至星期一            |
| sunday_to_monday       | 星期六紧接着星期一                              |
| next_monday_or_tuesday | 把星期六移至星期一，并把星期日/星期一移至星期二 |
| previous_friday        | 把星期六与星期日移至上一个星期五                |
| next_monday            | 把星期六与星期日移至下一个星期一                |

### 定义节假日日历

以下示例定义一个美国的部分自定义节假日：

```python
import datetime
from pandas.tseries.holiday import Holiday, USMemorialDay, \
    AbstractHolidayCalendar, nearest_workday, MO 

# 定义一个节假日日历的子类
class ExampleCalendar(AbstractHolidayCalendar):
    rules = [
        USMemorialDay, # 美国纪念日
        # 独立日，取最近的工作日（上文规则）
        Holiday('July 4th', month=7, day=4, observance=nearest_workday),
        # 哥伦布纪念日（十月第二个星期一）
        Holiday('Columbus Day', month=10, day=1,
                offset=pd.DateOffset(weekday=MO(2)))]

cal = ExampleCalendar()

# 取出2012的节假日
cal.holidays(datetime.datetime(2012, 1, 1), datetime.datetime(2012, 12, 31))
# DatetimeIndex(['2012-05-28', '2012-07-04', '2012-10-08'], dtype='datetime64[ns]', freq=None)
```

其中 `weekday=MO(2)` 相当于 `2 * Week(weekday=2)`。

### 使用节假日日历

我们可以使用上边定义的节假日日历作为频率，遇到正常工作日和这些节假日会跳过：

```python
# 使用日历作为频率
pd.date_range(start='7/1/2012', end='7/10/2012',
              freq=pd.offsets.CDay(calendar=cal)).to_pydatetime()

'''
array([datetime.datetime(2012, 7, 2, 0, 0),
       datetime.datetime(2012, 7, 3, 0, 0),
       datetime.datetime(2012, 7, 5, 0, 0),
       datetime.datetime(2012, 7, 6, 0, 0),
       datetime.datetime(2012, 7, 9, 0, 0),
       datetime.datetime(2012, 7, 10, 0, 0)], dtype=object)
'''

# 按日历规则偏移
offset = pd.offsets.CustomBusinessDay(calendar=cal)
datetime.datetime(2012, 5, 25) + offset
# Timestamp('2012-05-29 00:00:00')

# 按日历规则偏移
datetime.datetime(2012, 7, 3) + offset
# Timestamp('2012-07-05 00:00:00')

datetime.datetime(2012, 7, 3) + 2 * offset
# Timestamp('2012-07-06 00:00:00')

datetime.datetime(2012, 7, 6) + offset
# Timestamp('2012-07-09 00:00:00')
```

### 自定义日历类的操作

`AbstractHolidayCalendar` 类可使用的最大最小值及修改方法：

```python
# 查看
AbstractHolidayCalendar.start_date
# Timestamp('1970-01-01 00:00:00')
AbstractHolidayCalendar.end_date
# Timestamp('2200-12-31 00:00:00')

# 修改
AbstractHolidayCalendar.start_date = datetime.datetime(2012, 1, 1)
AbstractHolidayCalendar.end_date = datetime.datetime(2012, 12, 31)

cal.holidays()
# DatetimeIndex(['2012-05-28', '2012-07-04', '2012-10-08'], dtype='datetime64[ns]', f
```

### 查看日历的规则

以下是访问日历，查看日历规则，附加多日历规则的方法：

```python
from pandas.tseries.holiday import get_calendar, HolidayCalendarFactory,\
    USLaborDay

cal = get_calendar('ExampleCalendar')
# 查看日历规则
cal.rules
'''
[Holiday: Memorial Day (month=5, day=31, offset=<DateOffset: weekday=MO(-1)>),
 Holiday: July 4th (month=7, day=4, observance=<function nearest_workday at 0x7f8f801d1940>),
 Holiday: Columbus Day (month=10, day=1, offset=<DateOffset: weekday=MO(+2)>)]
'''

# 附加规则
new_cal = HolidayCalendarFactory('NewExampleCalendar', cal, USLaborDay)
new_cal.rules
'''
[Holiday: Labor Day (month=9, day=1, offset=<DateOffset: weekday=MO(+1)>),
 Holiday: Memorial Day (month=5, day=31, offset=<DateOffset: weekday=MO(-1)>),
 Holiday: July 4th (month=7, day=4, observance=<function nearest_workday at 0x7f65445f1830>),
 Holiday: Columbus Day (month=10, day=1, offset=<DateOffset: weekday=MO(+2)>)]
'''
```

## 时间增量 / 时长

### 生成时长数据

`Timedelta` 数据类型用来代表时间增量，两个固定时间相减会产生时差：

```python
# 两个固定时间相减
pd.Timestamp('2020-11-01 15') - pd.Timestamp('2020-11-01 14')
# Timedelta('0 days 01:00:00')

pd.Timestamp('2020-11-01 08') - pd.Timestamp('2020-11-02 08')
# Timedelta('-1 days +00:00:00')
```

按以下格式传入字符串：

```python
# 一天
pd.Timedelta('1 days')
# Timedelta('1 days 00:00:00')

pd.Timedelta('1 days 00:00:00')
# Timedelta('1 days 00:00:00')

pd.Timedelta('1 days 2 hours')
# Timedelta('1 days 02:00:00')

pd.Timedelta('-1 days 2 min 3us')
# Timedelta('-2 days +23:57:59.999997'
```

用关键字参数指定时间：

```python
pd.Timedelta(days=5, seconds=10)
# Timedelta('5 days 00:00:10')

pd.Timedelta(minutes=3, seconds=2)
# Timedelta('0 days 00:03:02')

# 可以实现指定分钟有多少天，多少小时
pd.Timedelta(minutes=3242)
```

使用带周期量的偏移量别名：

```python
# 一天
pd.Timedelta('1D')
# Timedelta('1 days 00:00:00')

# 两周
pd.Timedelta('2W')
# Timedelta('14 days 00:00:00')

# 一天2小时3分钟4秒
pd.Timedelta('1D2H3M4S')
```

带单位的整型数字：

```python
# 一天
pd.Timedelta(1, unit='d')

# 100 秒
pd.Timedelta(100, unit='s')
# Timedelta('0 days 00:01:40')

# 4 周
pd.Timedelta(4, unit='w')
# Timedelta('28 days 00:00:00')
```

Python内置的datetime.timedelta或者Numpy的np.timedelta64：

```python
import datetime
import numpy as np

# 一天10分钟
pd.Timedelta(datetime.timedelta(days=1, minutes=10))
# Timedelta('1 days 00:10:00')

# 100纳秒
pd.Timedelta(np.timedelta64(100, 'ns'))
# Timedelta('0 days 00:00:00.000000100')
```

负值：

```
# 负值
pd.Timedelta('-1min')
# Timedelta('-1 days +23:59:00')

# 空值，缺失值
pd.Timedelta('nan')
# NaT

# pd.Timedelta('nat')
# NaT
```

标准字符串（ISO 8601 Duration strings）：

```python
# ISO 8601 Duration strings
pd.Timedelta('P0DT0H1M0S')
# Timedelta('0 days 00:01:00')

pd.Timedelta('P0DT0H0M0.000000123S')
# Timedelta('0 days 00:00:00.000000')
```

也可以用 DateOffsets (Day, Hour, Minute, Second, Milli, Micro, Nano) 来构建：

```python
pd.Timedelta(pd.offsets.Second(2))
# Timedelta('0 days 00:00:02')
```

### to_timedelta

可以直接生成单个时长数据：

```python
pd.to_timedelta('1 days 06:05:01.00003')
# Timedelta('1 days 06:05:01.000030')
pd.to_timedelta('15.5us')
# Timedelta('0 days 00:00:00.000015')

pd.to_timedelta(pd.offsets.Day(3))
# Timedelta('3 days 00:00:00')

pd.to_timedelta('15.5min')
# Timedelta('0 days 00:15:30')

pd.to_timedelta(124524564574835)
# Timedelta('1 days 10:35:24.564574835')
```

类列表生成`TimedeltaIndex`数据：

```python
pd.to_timedelta(['1 days 06:05:01.00003', '15.5us', 'nan'])
# TimedeltaIndex(['1 days 06:05:01.000030', '0 days 00:00:00.000015', NaT], dtype='timedelta64[ns]', freq=None)
pd.to_timedelta(np.arange(5), unit='s')
# TimedeltaIndex(['00:00:00', '00:00:01', '00:00:02', '00:00:03', '00:00:04'], dtype='timedelta64[ns]', freq=None)
pd.to_timedelta(np.arange(5), unit='d')
# TimedeltaIndex(['0 days', '1 days', '2 days', '3 days', '4 days'], dtype='timedelta64[ns]', freq=None)
```

如时间戳数据一样，时长数据的存储也有上下限：

```python
pd.Timedelta.min
# Timedelta('-106752 days +00:12:43.145224')
pd.Timedelta.max
# Timedelta('106751 days 23:47:16.854775')
```

### 时长的操作

时长可以相加：

```
pd.Timedelta(pd.offsets.Day(2)) + pd.Timedelta(pd.offsets.Second(2)) +\
pd.Timedelta('00:00:00.000123')
# Timedelta('2 days 00:00:02.000123')
```

以下是一些操作示例：

```python
s = pd.Series(pd.date_range('2012-1-1', periods=3, freq='D'))
td = pd.Series([pd.Timedelta(days=i) for i in range(3)])
df = pd.DataFrame({'A': s, 'B': td})
df
'''
           A      B
0 2012-01-01 0 days
1 2012-01-02 1 days
2 2012-01-03 2 days
'''
df['C'] = df['A'] + df['B']
df
'''
           A      B          C
0 2012-01-01 0 days 2012-01-01
1 2012-01-02 1 days 2012-01-03
2 2012-01-03 2 days 2012-01-05
'''
df.dtypes
'''
A     datetime64[ns]
B    timedelta64[ns]
C     datetime64[ns]
dtype: object
'''
s - s.max()
'''
0   -2 days
1   -1 days
2    0 days
dtype: timedelta64[ns]
'''
s - datetime.datetime(2011, 1, 1, 3, 5)
'''
0   364 days 20:55:00
1   365 days 20:55:00
2   366 days 20:55:00
dtype: timedelta64[ns]
'''
s + datetime.timedelta(minutes=5)
'''
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]
'''
s + pd.offsets.Minute(5)
'''
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]
'''
s + pd.offsets.Minute(5) + pd.offsets.Milli(5)
'''
0   2012-01-01 00:05:00.005
1   2012-01-02 00:05:00.005
2   2012-01-03 00:05:00.005
dtype: datetime64[ns]
'''

# 两个时间标量之间想减
y = s - s[0]
y
'''
0   0 days
1   1 days
2   2 days
dtype: timedelta64[ns]
'''
# 位移后
y = s - s.shift()
y
'''
0      NaT
1   1 days
2   1 days
dtype: timedelta64[ns]
'''
# 绝对值会将负数变为正数
td1 = pd.Timedelta('-1 days 2 hours 3 seconds')
abs(td1)
# Timedelta('1 days 02:00:03')
```

### 时长序列的统计

时长序列可以做统计性计算：

```python
y2 = pd.Series(pd.to_timedelta(['-1 days +00:00:05',
                                'nat',
                                '-1 days +00:00:05',
                                '1 days']))
y2
'''
0   -1 days +00:00:05
1                 NaT
2   -1 days +00:00:05
3     1 days 00:00:00
dtype: timedelta64[ns]
'''
y2.mean()
# Timedelta('-1 days +16:00:03.333333')
y2.median()
# Timedelta('-1 days +00:00:05')
y2.quantile(.1)
# Timedelta('-1 days +00:00:05')
y2.sum()
# Timedelta('-1 days +00:00:10')
```

## 时长频率单位转换

### 频率单位转换

将时长值转为指定单位：

```python
december = pd.Series(pd.date_range('20121201', periods=4))
january = pd.Series(pd.date_range('20130101', periods=4))
td = january - december # 生成时长序列
# 修改指定值
td[2] += datetime.timedelta(minutes=5, seconds=3)
td[3] = np.nan
# 转换为天
td / np.timedelta64(1, 'D')
'''
0    31.000000
1    31.000000
2    31.003507
3          NaN
dtype: float64
'''
# 转换后类型转为浮点型
```

使用类型转换会失去一定的精度：

```python
td.astype('timedelta64[D]')
'''
0    31.0
1    31.0
2    31.0
3     NaN
dtype: float64
'''
```

其他单位的转换：

```python
# 转为秒
td / np.timedelta64(1, 's')
'''
0    2678400.0
1    2678400.0
2    2678703.0
3          NaN
dtype: float64
'''
td.astype('timedelta64[s]')
'''
0    2678400.0
1    2678400.0
2    2678703.0
3          NaN
dtype: float64
'''
# 转为月份
td / np.timedelta64(1, 'M')
'''
0    1.018501
1    1.018501
2    1.018617
3         NaN
dtype: float64
'''
```

### 时长计算

可以和标量或者序列做算术运算得到新的时长：

```python
td * -1
'''
0   -31 days +00:00:00
1   -31 days +00:00:00
2   -32 days +23:54:57
3                  NaT
dtype: timedelta64[ns]
'''
td * pd.Series([1, 2, 3, 4])
'''
0   31 days 00:00:00
1   62 days 00:00:00
2   93 days 00:15:09
3                NaT
dtype: timedelta64[ns]
'''
```

### 特殊频率

有时候我们需要特殊的频率，比如一个机器三天四小时做一次周期生产：

```python
td // pd.Timedelta(days=3, hours=4)
'''
0    9.0
1    9.0
2    9.0
3    NaN
dtype: float64
'''
pd.Timedelta(days=3, hours=4) // td
'''
0    0.0
1    0.0
2    0.0
3    NaN
dtype: float64
'''
```

也可以取模 mod (%) 和地板除 divmod ：

```python
pd.Timedelta(hours=37) % datetime.timedelta(hours=2)
#Timedelta('0 days 01:00:00')

# divmod against a timedelta-like returns a pair (int, Timedelta)
divmod(datetime.timedelta(hours=2), pd.Timedelta(minutes=11))
# (10, Timedelta('0 days 00:10:00'))

# divmod against a numeric returns a pair (Timedelta, Timedelta)
divmod(pd.Timedelta(hours=25), 86400000000000)
# (Timedelta('0 days 00:00:00.000000'), Timedelta('0 days 01:00:00'))
```

### 其他

```python
# 将时长时序计算为秒（Series 和 total_seconds）
s = pd.Series(pd.to_timedelta(np.arange(5), unit='d'))
s.dt.total_seconds()
```

## 时长的属性

### 基础属性

可以取出一个时长数据中的组成部分：

```python
tds = pd.Timedelta('31 days 5 min 3 sec')
tds.days
# 31
tds.seconds
# 303
 (-tds).seconds
# 86097
```

### dt 访问器

利用 dt 访问器可以返回天，秒，微秒，纳秒属性直接访问 Timedelta 或 TimedeltaIndex 的各个组成部分：

```python
td.dt.days
'''
0    31.0
1    31.0
2    31.0
3     NaN
dtype: float64
'''
td.dt.seconds
'''
0      0.0
1      0.0
2    303.0
3      NaN
dtype: float64
```

### 检索显示值

components 可以检索显示的值：

```python
td.dt.components
'''
   days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds
0  31.0    0.0      0.0      0.0           0.0           0.0          0.0
1  31.0    0.0      0.0      0.0           0.0           0.0          0.0
2  31.0    0.0      5.0      3.0           0.0           0.0          0.0
3   NaN    NaN      NaN      NaN           NaN           NaN          NaN
'''
td.dt.components.seconds
'''
0    0.0
1    0.0
2    3.0
3    NaN
Name: seconds, dtype: float64
'''
```

### 转换为标准格式

You can convert a Timedelta to an ISO 8601 Duration string with the method

可以使用 `.isoformat` 将 Timedelta 时长数据转换为 ISO 8601 Duration string（国际标准化时长字符串）：

```python
pd.Timedelta(days=6, minutes=50, seconds=3,
             milliseconds=10, microseconds=10,
             nanoseconds=12).isoformat()
#'P6DT0H50M3.010010012S'
```

## 时长索引 [timedelta](https://pandas.pydata.org/pandas-docs/stable/user_guide/timedeltas.html?highlight=timedeltaindex)

### 无频率时长索引

以下是定义一个无频率的时长索引：

```python
pd.TimedeltaIndex(['1 days', '1 days, 00:00:05',
                   np.timedelta64(2, 'D'),
                   datetime.timedelta(days=2, seconds=2)])

# TimedeltaIndex(['1 days 00:00:00', '1 days 00:00:05', '2 days 00:00:00',
#                 '2 days 00:00:02'],
#                dtype='timedelta64[ns]', freq=None)
```

### 有频率时长索引

`freq='infer'` 可以自动推断频率：

```python
pd.TimedeltaIndex(['0 days', '10 days', '20 days'], freq='infer')
# TimedeltaIndex(['0 days', '10 days', '20 days'], dtype='timedelta64[ns]', freq='10D'
```

使用 `pd.timedelta_range()` 可以非常方便地按频率生成：

```python
pd.timedelta_range(start='1 day', periods=4)
'''
TimedeltaIndex(['1 days', '2 days', '3 days', '4 days'],
               dtype='timedelta64[ns]', freq='D')
'''
# 不包含开始
pd.timedelta_range(start='1 day', periods=4, closed='right')
# 频率指定为 6小时
pd.timedelta_range(start='1 day', end='2 days', freq='6H')
# 指定开始结束时间和周期
pd.timedelta_range(start='1 day', end='5 days', periods=4)
```

### 访问

按索引访问数据也很方便，与普通时序索引一样：

```python
s = pd.Series(
    np.arange(100),
    index=pd.timedelta_range("1 days", periods=100, freq="h"),
)


print(s)
s['1 day': "2 day"]
s["1 day 01:00:00"]
s[pd.Timedelta("1 day 1h")]
s["1 day":"1 day 5 hours"]
s.resample("D").mean()
```

## 时间跨度 Period

### Period 对象

周期代表时间跨度（例如一天，一个月，一个季度等）。 您可以使用以下频率别名通过 freq 关键字指定范围。 因为 freq 代表周期的跨度，所以它不能像“ -3D”那样为负数。

```python
# 年，结束于12月为一个周期
pd.Period('2012', freq='A-DEC')
# Period('2012', 'A-DEC')

# 一天为一个周期
pd.Period('2012-1-1', freq='D')
# Period('2012-01-01', 'D')

# 一小时为一个周期
pd.Period('2012-1-1 19:00', freq='H')
# Period('2012-01-01 19:00', 'H')

# 五小时为一个周期
pd.Period('2012-1-1 19:00', freq='5H')
# Period('2012-01-01 19:00', '5H')
```

## 周期操作

### 计算操作

从周期中添加和减去整数会按其自身的频率移动周期。 具有不同频率（跨度）的Period 之间不允许进行算术运算。

```python
# 一年一个周期
p = pd.Period('2012', freq='A-DEC')

p + 1 # 加一个周期，加一年
# Period('2013', 'A-DEC')

p - 3 # 减少一个周期，减去三年
# Period('2009', 'A-DEC')

# 两月一个周期
p = pd.Period('2012-01', freq='2M')
p + 2 # 加两个周期，到五月据的周期
# Period('2012-05', '2M')

p - 1 # 减去一个周期
# Period('2011-11', '2M')

# 周期频率不同不能计算，会报 IncompatibleFrequency 错误
p == pd.Period('2012-01', freq='3M')
```

### 与时长、偏移操作

如果“周期”频率是每天或更高（D，H，T，S，L，U，N），则如果结果可以具有相同的频率，则可以添加偏移量和类似timedelta的值。 否则，将引发 ValueError。

```python
# 定义一个小时频率的周期
p = pd.Period('2014-07-01 09:00', freq='H')
p + pd.offsets.Hour(2) # 加两个小时
# Period('2014-07-01 11:00', 'H')

p + datetime.timedelta(minutes=120) # 加120分钟
# Period('2014-07-01 11:00', 'H')

p + np.timedelta64(7200, 's') # 7200 秒
# Period('2014-07-01 11:00', 'H')

p + pd.offsets.Minute(5) # 偏移5分钟
# ValueError: Input has different freq from Period(freq=H)
```

如果“周期”具有其他频率，则只能添加相同的偏移量。 否则，将引发ValueError。

```python
p = pd.Period('2014-07', freq='M')
p + pd.offsets.MonthEnd(3)
# Period('2014-10', 'M')
p + pd.offsets.MonthBegin(3)
# ValueError: Input has different freq from Period(freq=M)
```

相同频率的 Period 实例之差将返回它们之间的频率单位数：

```python
pd.Period('2012', freq='A-DEC') - pd.Period('2002', freq='A-DEC')
# <10 * YearEnds: month=12>
```

## 周期类型及转换

### 周期类型 Period dtypes

PeriodIndex 具有自己独有的 dtype。 这是一个类似于时区感知 dtype 的 pandas 扩展 (datetime64[ns, tz])）。

周期 dtype 拥有 freq 属性，并使用频率字符串以诸如 period[D]或period[M]之类的period[freq] 表示。

```python
pi = pd.period_range('2016-01-01', periods=3, freq='M')
pi
# PeriodIndex(['2016-01', '2016-02', '2016-03'], dtype='period[M]', freq='M')

pi.dtype
# period[M]
```

### 周期转换

可以通过asfreq方法转换Period和PeriodIndex的频率。 让我们从2011财年开始，到12月结束：

```python
p = pd.Period('2011', freq='A-DEC')
p
# Period('2011', 'A-DEC')
```

我们可以将其转换为每月频率。 使用how参数，我们可以指定返回起始月份还是结束月份：

```python
p.asfreq('M', how='start')
# Period('2011-01', 'M')

p.asfreq('M', how='end')
# Period('2011-12', 'M')
```

为方便起见，提供了速记“s”和“e”来简写：

```python
p.asfreq('M', 's')
# Period('2011-01', 'M')

p.asfreq('M', 'e')
# Period('2011-12', 'M')
```

转换为“超级周期”（例如，年度频率是每季度一次的超级周期）会自动返回包含输入期间的超级周期：

```python
p = pd.Period('2011-12', freq='M')
p.asfreq('A-NOV')
# Period('2012', 'A-NOV')
```

请注意，由于我们将年度频率转换为在11月结束的年度频率，因此2011年12月的月度实际上是2012年A-NOV期间。

具有固定频率的周期转换对于处理经济学、商业和其他领域共有的各种季度数据特别有用。 许多组织定义相对于其会计年度开始和结束月份的季度。 因此，2011年第一季度可能会在2010年或2011年之前的几个月内开始。通过锚定频率，Pandas 适用于Q-JAN 至 Q-DEC 的所有季度频率。

Q-DEC 定义常规日历季度：

```python
p = pd.Period('2012Q1', freq='Q-DEC')
p.asfreq('D', 's')
# Period('2012-01-01', 'D')

p.asfreq('D', 'e')
# Period('2012-03-31', 'D')
```

Q-MAR 定义3月的会计年度结束：

```python
p = pd.Period('2011Q4', freq='Q-MAR')
p.asfreq('D', 's')
# Period('2011-01-01', 'D')

p.asfreq('D', 'e')
# Period('2011-03-31', 'D')
```

## 周期索引

### PeriodIndex

可以使用 period_range 可以构造 Period 序列：

```python
prng = pd.period_range('1/1/2011', '1/1/2012', freq='M')
prng
'''
PeriodIndex(['2011-01', '2011-02', '2011-03', '2011-04', '2011-05', '2011-06',
             '2011-07', '2011-08', '2011-09', '2011-10', '2011-11', '2011-12',
             '2012-01'],
            dtype='period[M]', freq='M')
'''
```

pd.PeriodIndex 也可以直接构建：

```python
pd.PeriodIndex(['2011-1', '2011-2', '2011-3'], freq='M')
# PeriodIndex(['2011-01', '2011-02', '2011-03'], dtype='period[M]', freq='M')
```

### 频率匹配

通过倍频将输出一个周期范围，该周期具有倍频范围:

```python
pd.period_range(start='2014-01', freq='3M', periods=4)
# PeriodIndex(['2014-01', '2014-04', '2014-07', '2014-10'], dtype='period[3M]', freq='3M')
```

如果 start或 end 是 Period 对象，则它们将用作 PeriodIndex 的锚定端点，其频率与PeriodIndex 构造函数的频率匹配。

```python
pd.period_range(start=pd.Period('2017Q1', freq='Q'),
                end=pd.Period('2017Q2', freq='Q'),
                freq='M')
# PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'], dtype='period[M]', freq='M')
```

就像 DatetimeIndex 一样，PeriodInde x也可以用于索引对象：

```python
ps = pd.Series(np.random.randn(len(prng)), prng)
ps
'''
2011-01    2.518126
2011-02    1.320531
2011-03   -1.734174
2011-04   -1.633595
2011-05   -1.378595
2011-06    0.811348
2011-07   -1.129544
2011-08   -0.125929
2011-09   -0.236788
2011-10   -1.465034
2011-11    0.042106
2011-12    0.895732
2012-01   -0.026086
Freq: M, dtype: float64
'''
```

### 计算

PeriodIndex 支持与 Period 相同的规则加法和减法:

```python
idx = pd.period_range('2014-07-01 09:00', periods=5, freq='H')
idx
'''
PeriodIndex(['2014-07-01 09:00', '2014-07-01 10:00', '2014-07-01 11:00',
             '2014-07-01 12:00', '2014-07-01 13:00'],
            dtype='period[H]', freq='H')
'''


idx + pd.offsets.Hour(2)
'''
PeriodIndex(['2014-07-01 11:00', '2014-07-01 12:00', '2014-07-01 13:00',
             '2014-07-01 14:00', '2014-07-01 15:00'],
            dtype='period[H]', freq='H')
'''
idx = pd.period_range('2014-07', periods=5, freq='M')
idx
# PeriodIndex(['2014-07', '2014-08', '2014-09', '2014-10', '2014-11'], dtype='period[M]', freq='M')

idx + pd.offsets.MonthEnd(3)
# PeriodIndex(['2014-10', '2014-11', '2014-12', '2015-01', '2015-02'], dtype='period[M]', freq='M')
```

### 周期索引转换

如果想转换为周期，可以用 .astype(...)， 它允许人们更改 PeriodIndex 的频率，例如.asfreq()，并将 DatetimeIndex 转换为PeriodIndex，例如to_period()：

```python
# 频率从月转为天
pi.astype('period[D]')
# PeriodIndex(['2016-01-31', '2016-02-29', '2016-03-31'], dtype='period[D]', freq='D')

# 转换为 DatetimeIndex
pi.astype('datetime64[ns]')
# DatetimeIndex(['2016-01-01', '2016-02-01', '2016-03-01'], dtype='datetime64[ns]', freq='MS')

# 转换为 PeriodIndex
dti = pd.date_range('2011-01-01', freq='M', periods=3)
dti
# DatetimeIndex(['2011-01-31', '2011-02-28', '2011-03-31'], dtype='datetime64[ns]', freq='M')
dti.astype('period[M]')
# PeriodIndex(['2011-01', '2011-02', '2011-03'], dtype='period[M]', freq='M')
```

### 索引读取数据

通过索引查询数据：

```python
ps['2011-01']
# -2.9169013294054507

ps[datetime.datetime(2011, 12, 25):]
'''
2011-12    2.261385
2012-01   -0.329583
Freq: M, dtype: float64
'''

ps['10/31/2011':'12/31/2011']
'''
2011-10    0.056780
2011-11    0.197035
2011-12    2.261385
Freq: M, dtype: float64
'''
```

传递一个表示比 PeriodIndex 更低的频率的字符串将返回部分切片的数据。

```python
ps['2011']
'''
2011-01   -2.916901
2011-02    0.514474
2011-03    1.346470
2011-04    0.816397
2011-05    2.258648
2011-06    0.494789
2011-07    0.301239
2011-08    0.464776
2011-09   -1.393581
2011-10    0.056780
2011-11    0.197035
2011-12    2.261385
Freq: M, dtype: float64
'''

dfp = pd.DataFrame(np.random.randn(600, 1),
                   columns=['A'],
                   index=pd.period_range('2013-01-01 9:00',
                                         periods=600,
                                         freq='T'))

dfp
'''
                         A
2013-01-01 09:00 -0.538468
2013-01-01 09:01 -1.365819
2013-01-01 09:02 -0.969051
2013-01-01 09:03 -0.331152
2013-01-01 09:04 -0.245334
...                    ...
2013-01-01 18:55  0.522460
2013-01-01 18:56  0.118710
2013-01-01 18:57  0.167517
2013-01-01 18:58  0.922883
2013-01-01 18:59  1.721104

[600 rows x 1 columns]
'''
dfp['2013-01-01 10H']
'''
                         A
2013-01-01 10:00 -0.308975
2013-01-01 10:01  0.542520
2013-01-01 10:02  1.061068
2013-01-01 10:03  0.754005
2013-01-01 10:04  0.352933
...                    ...
2013-01-01 10:55 -0.865621
2013-01-01 10:56 -1.167818
2013-01-01 10:57 -2.081748
2013-01-01 10:58 -0.527146
2013-01-01 10:59  0.802298

[60 rows x 1 columns]
'''
```

与DatetimeIndex一样，端点将包含在结果中。 下面的示例对从10:00到11:59的数据进行切片。

```python
dfp['2013-01-01 10H':'2013-01-01 11H']
'''
                         A
2013-01-01 10:00 -0.308975
2013-01-01 10:01  0.542520
2013-01-01 10:02  1.061068
2013-01-01 10:03  0.754005
2013-01-01 10:04  0.352933
...                    ...
2013-01-01 11:55 -0.590204
2013-01-01 11:56  1.539990
2013-01-01 11:57 -1.224826
2013-01-01 11:58  0.578798
2013-01-01 11:59 -0.685496

[120 rows x 1 columns]
'''
```

## 超出时间戳范围时间

如果您的数据超出时间戳记范围，请参阅时间戳记限制，然后可以使用PeriodIndex和/或Period of Periods进行计算。

```python
span = pd.period_range('1215-01-01', '1381-01-01', freq='D')
span
'''
PeriodIndex(['1215-01-01', '1215-01-02', '1215-01-03', '1215-01-04',
             '1215-01-05', '1215-01-06', '1215-01-07', '1215-01-08',
             '1215-01-09', '1215-01-10',
             ...
             '1380-12-23', '1380-12-24', '1380-12-25', '1380-12-26',
             '1380-12-27', '1380-12-28', '1380-12-29', '1380-12-30',
             '1380-12-31', '1381-01-01'],
            dtype='period[D]', length=60632, freq='D')
'''
```

从基于int64的YYYYMMDD表示形式进行转换。

```python
s = pd.Series([20121231, 20141130, 99991231])
s
'''
0    20121231
1    20141130
2    99991231
dtype: int64
'''
def conv(x):
    return pd.Period(year=x // 10000, 
                     month=x // 100 % 100,
                     day=x % 100, freq='D')

s.apply(conv)
'''
0    2012-12-31
1    2014-11-30
2    9999-12-31
dtype: period[D]
'''
s.apply(conv)[2]
# Period('9999-12-31', 'D')
```

这些可以很容易地转换为PeriodIndex：

```python
span = pd.PeriodIndex(s.apply(conv))
span
# PeriodIndex(['2012-12-31', '2014-11-30', '9999-12-31'], dtype='period[D]', freq='D')
```

## 时间重采样

### 重采样基础使用

resample() 是一个基于时间的分组依据，后面是每个分组的聚合方法。

```python
rng = pd.date_range('1/1/2012', periods=1000, freq='S')
ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)
# 每5分钟进行一次聚合
ts.resample('5Min').sum()
'''
2012-01-01 00:00:00    74477
2012-01-01 00:05:00    74834
2012-01-01 00:10:00    76489
2012-01-01 00:15:00    25095
Freq: 5T, dtype: int64
'''
```

重采样功能非常灵活，您可以指定许多不同的参数来控制频率转换和重采样操作。

通过分派可用的任何函数（类似于 grouby）都可以作为返回对象的方法，包括 sum，mean，std，sem，max，min，mid，median，first，last，ohlc：

```python
ts.resample('5Min').mean() # 平均
ts.resample('5Min').max() # 最大值
```

## 美国线

美国线（英语：Open-High-Low-Close chart，OHLC chart），以竖立的线条表现股票价格的变化，可以呈现“开盘价、最高价、最低价、收盘价”，竖线呈现最高价和最低价间的价差间距，左侧横线代表开盘价，右侧横线代表收盘价，绘制上较K线简单。另有一种美国线仅呈现“最高价、最低价、收盘价”（HLC）三项讯息。

```python
ts.resample('5Min').ohlc()
'''                     open  high  low  close
2012-01-01 00:00:00    84   499    5    435
2012-01-01 00:05:00   229   497    1    440
2012-01-01 00:10:00   171   499    1    201
2012-01-01 00:15:00   431   499    0    289
'''
```

### 开闭区间指定

对于采样，可以将 closed 设置为“ left”或“ right”，以指定关闭区间的哪一端：

```python
ts.resample('5Min', closed='right').mean()
ts.resample('5Min', closed='left').mean()
```

### 输出结果控制

像 label 和 loffset 这样的参数用于操纵结果标签。 label 指定结果是用间隔的开始还是结束标记，loffset 对输出标签执行时间调整。

```python
ts.resample('5Min').mean()  # 默认 label='left'
ts.resample('5Min', label='left').mean()
ts.resample('5Min', label='left', loffset='1s').mean()
```

### 上采样

上采样又称图像插值，其主要目的是通过放大原图像，进而可以在更高分辨率的设备上显示。图像放大几乎都是采用内插值方法，即在原有图像像素的基础上在像素点之间采用合适的插值算法插入新的元素。

对于上采样，您可以指定一种上采样的方法，并指定 limit 参数以对创建的间隙进行插值：

```python
# 从每秒到每250毫秒
ts[:2].resample('250L').asfreq()
'''
2012-01-01 00:00:00.000    84.0
2012-01-01 00:00:00.250     NaN
2012-01-01 00:00:00.500     NaN
2012-01-01 00:00:00.750     NaN
2012-01-01 00:00:01.000    61.0
Freq: 250L, dtype: float64
'''

ts[:2].resample('250L').ffill()
'''
2012-01-01 00:00:00.000    84
2012-01-01 00:00:00.250    84
2012-01-01 00:00:00.500    84
2012-01-01 00:00:00.750    84
2012-01-01 00:00:01.000    61
Freq: 250L, dtype: int64
'''

ts[:2].resample('250L').ffill(limit=2)
'''
2012-01-01 00:00:00.000    84.0
2012-01-01 00:00:00.250    84.0
2012-01-01 00:00:00.500    84.0
2012-01-01 00:00:00.750     NaN
2012-01-01 00:00:01.000    61.0
Freq: 250L, dtype: float64
'''
```

### 稀疏采样

压缩感知（Compressed sensing），也被称为压缩采样（Compressive sampling）或稀疏采样（Sparse sampling），是一种寻找欠定线性系统的稀疏解的技术。压缩感知被应用于电子工程尤其是信号处理中，用于获取和重构稀疏或可压缩的信号。

相对于要重采样的时间量，稀疏时间序列的点要少得多。 天真地对稀疏序列进行升采样可能会产生很多中间值。 当您不想使用一种方法来填充这些值时，例如 fill_method 为 None，则中间值将用 NaN 填充。由于重采样是基于时间的分组依据，因此以下是仅对并非全部为NaN的组进行有效重采样的方法。

```python
rng = pd.date_range('2014-1-1', periods=100, freq='D') + pd.Timedelta('1s')
ts = pd.Series(range(100), index=rng)

# 如果我们想对整个系列重新采样：
ts.resample('3T').sum()
'''
2014-01-01 00:00:00     0
2014-01-01 00:03:00     0
2014-01-01 00:06:00     0
2014-01-01 00:09:00     0
2014-01-01 00:12:00     0
                       ..
2014-04-09 23:48:00     0
2014-04-09 23:51:00     0
2014-04-09 23:54:00     0
2014-04-09 23:57:00     0
2014-04-10 00:00:00    99
Freq: 3T, Length: 47521, dtype: int64
'''
```

取而代之的是，我们只能对那些我们拥有点的组重新采样，如下所示：

```python
from functools import partial
from pandas.tseries.frequencies import to_offset

def round(t, freq):
    freq = to_offset(freq)
    return pd.Timestamp((t.value // freq.delta.value) * freq.delta.value)

ts.groupby(partial(round, freq='3T')).sum()
'''
2014-01-01     0
2014-01-02     1
2014-01-03     2
2014-01-04     3
2014-01-05     4
              ..
2014-04-06    95
2014-04-07    96
2014-04-08    97
2014-04-09    98
2014-04-10    99
Length: 100, dtype: int64
'''
```

### 聚合

类似于 aggregating API, groupby API, 和窗口方法 api, Resampler 也适用相关方法。重新采样DataFrame时，默认值是对具有相同功能的所有列进行操作：

```
df = pd.DataFrame(np.random.randn(1000, 3),
                  index=pd.date_range('1/1/2012', freq='S', periods=1000),
                  columns=['A', 'B', 'C'])

r = df.resample('3T')
r.mean()
'''
                            A         B         C
2012-01-01 00:00:00 -0.033823 -0.121514 -0.081447
2012-01-01 00:03:00  0.056909  0.146731 -0.024320
2012-01-01 00:06:00 -0.058837  0.047046 -0.052021
2012-01-01 00:09:00  0.063123 -0.026158 -0.066533
2012-01-01 00:12:00  0.186340 -0.003144  0.074752
2012-01-01 00:15:00 -0.085954 -0.016287 -0.050046
'''
```

我们可以选择一个或多个特定列:

```python
r['A'].mean()
'''
2012-01-01 00:00:00   -0.033823
2012-01-01 00:03:00    0.056909
2012-01-01 00:06:00   -0.058837
2012-01-01 00:09:00    0.063123
2012-01-01 00:12:00    0.186340
2012-01-01 00:15:00   -0.085954
Freq: 3T, Name: A, dtype: float64
'''

r[['A', 'B']].mean()
'''
                            A         B
2012-01-01 00:00:00 -0.033823 -0.121514
2012-01-01 00:03:00  0.056909  0.146731
2012-01-01 00:06:00 -0.058837  0.047046
2012-01-01 00:09:00  0.063123 -0.026158
2012-01-01 00:12:00  0.186340 -0.003144
2012-01-01 00:15:00 -0.085954 -0.016287
'''
```

多个聚合方式：

```
r['A'].agg([np.sum, np.mean, np.std])
r.agg([np.sum, np.mean]) # 每个列
# 不同的聚合方式
r.agg({'A': np.sum,
       'B': lambda x: np.std(x, ddof=1)})
# 用字符指定
r.agg({'A': 'sum', 'B': 'std'})
r.agg({'A': ['sum', 'std'], 'B': ['mean', 'std']})
```

如果索引不是时间，可以指定采样的时间列：

```python
# date 是一个普通列
df.resample('M', on='date').sum()
df.resample('M', level='d').sum() # 多层索引
```

迭代采样对象：

```python
small = pd.Series(range(6),
                  index=pd.to_datetime(['2017-01-01T00:00:00',
                                        '2017-01-01T00:30:00',
                                        '2017-01-01T00:31:00',
                                        '2017-01-01T01:00:00',
                                        '2017-01-01T03:00:00',
                                        '2017-01-01T03:05:00'])
                 )

resampled = small.resample('H')

for name, group in resampled:
    print("Group: ", name)
    print("-" * 27)
    print(group, end="\n\n")
```

## 时间类型之间的转换

本文介绍不同时间概念之间的相互转换。带时间戳的数据可以使用 to_period 转换为PeriodIndex-ed 数据，反之亦然可以使用 to_timestamp 转换为 PeriodIndex-ed 数据。

```python
rng = pd.date_range('1/1/2012', periods=5, freq='M')
ts = pd.Series(np.random.randn(len(rng)), index=rng)
ts
''' 
2012-01-31    1.931253
2012-02-29   -0.184594
2012-03-31    0.249656
2012-04-30   -0.978151
2012-05-31   -0.873389
Freq: M, dtype: float64
'''

ps = ts.to_period()
ps
'''
2012-01    1.931253
2012-02   -0.184594
2012-03    0.249656
2012-04   -0.978151
2012-05   -0.873389
Freq: M, dtype: float64
'''

ps.to_timestamp()
'''
2012-01-01    1.931253
2012-02-01   -0.184594
2012-03-01    0.249656
2012-04-01   -0.978151
2012-05-01   -0.873389
Freq: MS, dtype: float64
'''
```

“s”和“ e”可用于返回时间段开始或结束时的时间戳：

```python
ps.to_timestamp('D', how='s')
'''
2012-01-01    1.931253
2012-02-01   -0.184594
2012-03-01    0.249656
2012-04-01   -0.978151
2012-05-01   -0.873389
Freq: MS, dtype: float64
'''
```

在周期和时间戳之间转换可以使用一些方便的算术函数。 在以下示例中，我们将以11月结束的年度的季度频率转换为季度结束后的月末的上午9点：

```python
prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')
ts = pd.Series(np.random.randn(len(prng)), prng)
ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9
ts.head()
'''
1990-03-01 09:00   -0.109291
1990-06-01 09:00   -0.637235
1990-09-01 09:00   -1.735925
1990-12-01 09:00    2.096946
1991-03-01 09:00   -1.039926
Freq: H, dtype: float64
'''
```

## 时区

### 查看所有时间

以下其中任何一个变量可以看所有的时间名称，中国通用的北京时区使用 `'Asia/Shanghai'` 定义。

```python
from pytz import common_timezones, all_timezone
print(common_timezones)
print(all_timezones)
```

### 时区指定

在没有指定时区时，没不带时区的：

```python
rng = pd.date_range('3/6/2012 00:00', periods=15, freq='D')
rng.tz is None
# True
```

简单的时区指定：

```python
pd.date_range('2019-01-01', periods=3, freq='D', tz='US/Pacific')
pd.Timestamp('2019-01-01', tz='US/Pacific')
```

以下是指定时区的更多方法：

```python
import dateutil

# 使用 pytz 支持
rng_pytz = pd.date_range('3/6/2012 00:00', periods=3,
                         freq='D', tz='Europe/London')
rng_pytz.tz
# <DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>

# 使用 dateutil 支持
rng_dateutil = pd.date_range('3/6/2012 00:00', periods=3, freq='D')
# 转为伦敦所在的时区
rng_dateutil = rng_dateutil.tz_localize('dateutil/Europe/London')
rng_dateutil.tz
# tzfile('/usr/share/zoneinfo/Europe/London')

# dateutil 指定为 utc 时间
rng_utc = pd.date_range('3/6/2012 00:00', periods=3,
                        freq='D', tz=dateutil.tz.tzutc())
rng_utc.tz
# tzutc()

# datetime.timezone
rng_utc = pd.date_range('3/6/2012 00:00', periods=3,
                        freq='D', tz=datetime.timezone.utc)
rng_utc.tz
# datetime.timezone.utc
```

请注意，UTC 时区是 dateutil 中的特殊情况，应显式构造为 dateutil.tz.tzutc 的实例。

还可以首先显式构造其他时区对象：

```python
# pytz
tz_pytz = pytz.timezone('Europe/London')
rng_pytz = pd.date_range('3/6/2012 00:00', periods=3, freq='D')
rng_pytz = rng_pytz.tz_localize(tz_pytz)
rng_pytz.tz == tz_pytz
# True

# dateutil
tz_dateutil = dateutil.tz.gettz('Europe/London')
rng_dateutil = pd.date_range('3/6/2012 00:00', periods=3,
                             freq='D', tz=tz_dateutil)
ng_dateutil.tz == tz_dateutil
# True
```

### 时区转换

要将时区感知的 Pandas 对象从一个时区转换为另一个时区，可以使用 tz_convert 方法。

```python
rng_pytz.tz_convert('US/Eastern')
'''
DatetimeIndex(['2012-03-05 19:00:00-05:00', '2012-03-06 19:00:00-05:00',
               '2012-03-07 19:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq='D')
'''
```

可以在转换类型时指定：

```python
pd.Series('20210101').astype('datetime64[ns, Asia/Shanghai]')
'''
0   2021-01-01 00:00:00+08:00
dtype: datetime64[ns, Asia/Shanghai]
'''
```

### 本地时间确认

tz_localize 可能无法确定时间戳的 UTC 偏移量，因为本地时区中的夏时制（DST）导致一天中的某些时间发生两次（“时钟倒退”）。 提供以下选项：

- raise：引发 pytz.AmbiguousTimeError（默认行为）
- infer：尝试根据时间戳的单调性确定正确的偏移量
- NaT：用NaT代替模糊的时间
- bool：True 表示 DST 时间，False表示非 DST时间。 在一段时间内都支持类似布尔值的数组。

```python
rng_hourly = pd.DatetimeIndex(['11/06/2011 00:00', '11/06/2011 01:00',
                               '11/06/2011 01:00', '11/06/2011 02:00'])
rng_hourly.tz_localize('US/Eastern')
# AmbiguousTimeError: Cannot infer dst time from 2011-11-06 01:00:00, try using the 'ambiguous' argument
```

通过指定以下内容来处理这些模糊的时间：

```python
rng_hourly.tz_localize('US/Eastern', ambiguous='infer')
'''
DatetimeIndex(['2011-11-06 00:00:00-04:00', '2011-11-06 01:00:00-04:00',
               '2011-11-06 01:00:00-05:00', '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)
'''

rng_hourly.tz_localize('US/Eastern', ambiguous='NaT')
''' 
DatetimeIndex(['2011-11-06 00:00:00-04:00', 'NaT', 'NaT',
               '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)
'''

rng_hourly.tz_localize('US/Eastern', ambiguous=[True, True, False, False])
'''
DatetimeIndex(['2011-11-06 00:00:00-04:00', '2011-11-06 01:00:00-04:00',
               '2011-11-06 01:00:00-05:00', '2011-11-06 02:00:00-05:00'],
              dtype='datetime64[ns, US/Eastern]', freq=None)
```

### 本地化的无用时间

DST转换也可能会将本地时间提前1小时，从而创建不存在的本地时间（“时钟往前跳”）。 可以通过不存在的参数来控制使用不存在的时间对时间序列进行本地化的行为。 提供以下选项：

- 'raise'：引发 pytz.NonExistentTimeError（默认行为）
- “NaT”：用NaT替换不存在的时间
- 'shift_forward'：将不存在的时间向前移动到最接近的实时时间
- 'shift_backward'：将不存在的时间向后移动到最接近的实时时间
- timedelta对象：将不存在的时间偏移 timedelta 持续时间

```
dti = pd.date_range(start='2015-03-29 02:30:00', periods=3, freq='H')
# 2:30 is a nonexistent time
```

默认情况下，不存在时间的本地化将引发错误。

```
dti.tz_localize('Europe/Warsaw')
# NonExistentTimeError: 2015-03-29 02:30:00
```

将不存在的时间转换为NaT或移动时间:

```python
dti
'''
DatetimeIndex(['2015-03-29 02:30:00', '2015-03-29 03:30:00',
               '2015-03-29 04:30:00'],
              dtype='datetime64[ns]', freq='H')
'''
dti.tz_localize('Europe/Warsaw', nonexistent='shift_forward')
'''
DatetimeIndex(['2015-03-29 03:00:00+02:00', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')
'''
dti.tz_localize('Europe/Warsaw', nonexistent='shift_backward')
'''
DatetimeIndex(['2015-03-29 01:59:59.999999999+01:00',
                         '2015-03-29 03:30:00+02:00',
                         '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')
'''
dti.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta(1, unit='H'))
'''
DatetimeIndex(['2015-03-29 03:30:00+02:00', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')
'''
dti.tz_localize('Europe/Warsaw', nonexistent='NaT')
'''
DatetimeIndex(['NaT', '2015-03-29 03:30:00+02:00',
               '2015-03-29 04:30:00+02:00'],
              dtype='datetime64[ns, Europe/Warsaw]', freq='H')
'''
```

### 时区 Series 操作

指定时区：

```python
s_naive = pd.Series(pd.date_range('20130101', periods=3))
# dtype: datetime64[ns]
s_aware = pd.Series(pd.date_range('20130101', periods=3, tz='US/Eastern'))
# dtype: datetime64[ns, US/Eastern]
```

时区转换：

```python
s_naive.dt.tz_localize('UTC').dt.tz_convert('US/Eastern')
s_naive.astype('datetime64[ns, US/Eastern]')
s_aware.to_numpy(dtype='datetime64[ns]')
```

## 区间间隔 pd.Interval

### 对象创建

构建 Interval 对象方法如下

```python
pd.Interval(left=0, right=5, closed='right')
```

参数介绍：

- left：有顺序的定值，间隔的左边界
- right：有顺序的定值，间隔的右边界
- closed：字符，可选 {‘right’, ‘left’, ‘both’, ‘neither’}, 默认为 ‘right’，区间是在左侧、右侧还是同时闭合，或者都不闭合

说明：

- 参数 left 和 right 必须具有相同的类型，必须能够比较它们，并且它们必须满足 left <= right
- 闭合区间（在数学中用方括号表示）包含其端点，即闭合区间[0，5]的特征是条件0 <= x <=5，这就是 close ='both' 所代表的意思
- 开放时间间隔（用括号表示的数学形式）不包含其端点，即开放时间间隔（0，5）的条件是0<x<5，这就是 closed ='nether' 代表的意思
- 间隔也可以半开或半闭，即[0，5）用0 <= x <5（closed ='left'）描述，（0，5] 用0 <x <= 5（ close ='right'）

### 创建间隔实例

可以构建不同类型的间隔，例如数字：

```python
iv = pd.Interval(left=0, right=5)
iv
'''
Interval(0, 5, closed='right')
'''
# 可以检查元素是否属于它
3.5 in iv # True
5.5 in iv # False

# 可以测试边界值
# closed ='right'，所以0 <x <= 5
0 in iv # False
5 in iv # True
0.0001 in iv # True
```

要创建时间间隔，您可以使用时间戳记作为界限：

```python
# 定义一个 2020 年的区间
year_2020 = pd.Interval(pd.Timestamp('2020-01-01 00:00:00'),
                        pd.Timestamp('2021-01-01 00:00:00'),
                        closed='left')

# 指定时间是否在2020年区间里
pd.Timestamp('2020-01-01 00:00') in year_2020
# True

# 2020 年时间区间的长度
year_2020.length
# Timedelta('366 days 00:00:00')
```

还可以创建时长区间间隔：

```python
# 定义一个时长区间，3秒到1天
time_deltas = pd.Interval(pd.Timedelta('3 seconds'),
                          pd.Timedelta('1 days'),
                          closed='both')

# 5分钟是否在时间区间里
pd.Timedelta('5 minutes') in time_deltas
# True

# 时长区间长度
time_deltas.length
# Timedelta('0 days 23:59:57')
```

### 属性

pd.Interval 支持以下属性：

```python
# 区间闭合之处
iv.closed # 'right'
# 检查间隔是否在左侧关闭
iv.closed_left # False
# 检查间隔是否在右侧关闭
iv.closed_right # True
# 间隔是否为空，表示该间隔不包含任何点
iv.is_empty # False
# 间隔的左边界
iv.left # 0
# 间隔的右边界
iv.right # 5
# 间隔的长度
iv.length # 5
# 间隔的中点
iv.mid # 2.5
# 间隔是否在左侧为开区间
iv.open_left # True
# 间隔是否在为开区间
iv.open_right # False
```

其中，Interval.is_empty 指示间隔是否为空，表示该间隔不包含任何点。

```python
# 包含点的间隔不为空
pd.Interval(0, 1, closed='right').is_empty # False

# 不包含任何点的间隔为空
pd.Interval(0, 0, closed='right').is_empty # True
pd.Interval(0, 0, closed='left').is_empty # True
pd.Interval(0, 0, closed='neither').is_empty # True

# 包含单个点的间隔不为空
pd.Interval(0, 0, closed='both').is_empty # False

# 一个IntervalArray 或 IntervalIndex 返回一个布尔 ndarray
# 它在位置上指示 Interval 是否为空
ivs = [pd.Interval(0, 0, closed='neither'),
       pd.Interval(1, 2, closed='neither')]
pd.arrays.IntervalArray(ivs).is_empty
# array([True, False])

# 缺失的值不认为是空的
ivs = [pd.Interval(0, 0, closed='neither'), np.nan]
pd.IntervalIndex(ivs).is_empty
# array([ True, False])
```

### 间隔部分重叠

pd.Interval.overlaps 检查两个Interval对象是否重叠，如果两个间隔共享一个公共点，则两个间隔会重叠，包括封闭的端点。 只有共同的开放端点的间隔不会重叠。

```python
i1 = pd.Interval(0, 2)
i2 = pd.Interval(1, 3)
i1.overlaps(i2) # True

i3 = pd.Interval(4, 5)
i1.overlaps(i3) # False
```

共享封闭端点的间隔重叠：

```python
i4 = pd.Interval(0, 1, closed='both')
i5 = pd.Interval(1, 2, closed='both')
i4.overlaps(i5) # True
```

只有共同的开放端点的间隔不会重叠：

```python
i6 = pd.Interval(1, 2, closed='neither')
i4.overlaps(i6) # False
```

### 计算操作

在间隔上使用 `+` 和 `*` 进行操作，并且该操作将应用于其每个范围，因此结果取决于绑定元素的类型：

```python
iv
# Interval(0, 5, closed='right')
shifted_iv = iv + 3
shifted_iv
# Interval(3, 8, closed='right')
extended_iv = iv * 10.0
extended_iv
# Interval(0.0, 50.0, closed='right')
```

### 区间的集合计算

推荐使用 `portion` （`pip install portion`）库来解决，portion 库（以前以python-intervals的形式分发）提供间隔的数据结构和操作。

```python
import portion as P

# 交集
P.closed(0, 2).intersection(P.closed(1, 3))
P.closed(0, 2) & P.closed(1, 3)
# [1,2]

# 并集
P.closed(0, 2).union(P.closed(1, 3))
P.closed(0, 2) | P.closed(1, 3)
# [0,3]

# 补集
P.closed(0, 2).complement()
# (-inf,0) | (2,+inf)
~P.closed(0, 1)
# (-inf,0) | (1,+inf)
~(P.open(-P.inf, 0) | P.open(1, P.inf))
# [0,1]
~P.open(-P.inf, P.inf)
# ()

# 差集
P.closed(0,2).difference(P.closed(1,2))
P.closed(0,2) - P.closed(1,2)
# [0,1)
P.closed(0, 4) - P.closed(1, 2)
# [0,1) | (2,4]
```

更多参考本站[portion 间隔数据操作](https://www.gairuo.com/p/python-portion)教程。